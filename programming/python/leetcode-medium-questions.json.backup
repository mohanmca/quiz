[
    {
        "type": "radiogroup",
        "questionType": "source-code",
        "name": "q1",
        "title": "**Stack Pattern - Valid Parentheses with Multiple Types**\n\nGiven a string containing '(', ')', '{', '}', '[' and ']', determine if the input string is valid. Opening brackets must be closed by the same type of brackets and in the correct order.\n\n**Example:** `s = \"([{}])\"` → `True`\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python\ndef isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack\n```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python\ndef isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack\n```"
    },
    {
        "type": "radiogroup",
        "name": "q2",
        "title": "**Sliding Window Pattern - Longest Substring Without Repeating Characters**\n\nGiven a string `s`, find the length of the longest substring without repeating characters.\n\n**Example:** `s = \"abcabcbb\"` → `3` (\"abc\")\n\n**What is the optimal Python solution using sliding window?**",
        "choices": [
            "```python
def lengthOfLongestSubstring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def lengthOfLongestSubstring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length
```"
    },
    {
        "type": "radiogroup",
        "name": "q3",
        "title": "**Heap Pattern - Top K Frequent Elements**\n\nGiven an integer array `nums` and an integer `k`, return the `k` most frequent elements.\n\n**Example:** `nums = [1,1,1,2,2,3], k = 2` → `[1,2]`\n\n**What is the optimal Python solution using heap?**",
        "choices": [
            "```python
import heapq\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
import heapq\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)
```"
    },
    {
        "type": "radiogroup",
        "name": "q4",
        "title": "**Tree Pattern - Binary Tree Level Order Traversal**\n\nGiven the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).\n\n**Example:** `[3,9,20,null,null,15,7]` → `[[3],[9,20],[15,7]]`\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python
from collections import deque\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
from collections import deque\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result
```"
    },
    {
        "type": "radiogroup",
        "name": "q5",
        "title": "**DAG Pattern - Course Schedule**\n\nThere are `numCourses` courses labeled from 0 to `numCourses - 1`. Given prerequisites array where `prerequisites[i] = [ai, bi]` indicates you must take course `bi` first to take course `ai`. Return `true` if you can finish all courses.\n\n**Example:** `numCourses = 2, prerequisites = [[1,0]]` → `true`\n\n**What is the optimal Python solution using topological sort?**",
        "choices": [
            "```python
from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    completed = 0\n    \n    while queue:\n        current = queue.popleft()\n        completed += 1\n        \n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return completed == numCourses
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    completed = 0\n    \n    while queue:\n        current = queue.popleft()\n        completed += 1\n        \n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return completed == numCourses
```"
    },
    {
        "type": "radiogroup",
        "name": "q6",
        "title": "**Prefix Sum Pattern - Subarray Sum Equals K**\n\nGiven an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.\n\n**Example:** `nums = [1,1,1], k = 2` → `2`\n\n**What is the optimal Python solution using prefix sum?**",
        "choices": [
            "```python
def subarraySum(nums, k):\n    count = 0\n    prefix_sum = 0\n    sum_count = {0: 1}  # prefix_sum: frequency\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum - k in sum_count:\n            count += sum_count[prefix_sum - k]\n        \n        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1\n    \n    return count
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def subarraySum(nums, k):\n    count = 0\n    prefix_sum = 0\n    sum_count = {0: 1}  # prefix_sum: frequency\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum - k in sum_count:\n            count += sum_count[prefix_sum - k]\n        \n        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1\n    \n    return count
```"
    },
    {
        "type": "radiogroup",
        "name": "q7",
        "title": "**Stack Pattern - Daily Temperatures**\n\nGiven an array of integers `temperatures`, return an array `answer` such that `answer[i]` is the number of days you have to wait after the `i-th` day to get a warmer temperature.\n\n**Example:** `temperatures = [73,74,75,71,69,72,76,73]` → `[1,1,4,2,1,1,0,0]`\n\n**What is the optimal Python solution using monotonic stack?**",
        "choices": [
            "```python
def dailyTemperatures(temperatures):\n    n = len(temperatures)\n    answer = [0] * n\n    stack = []  # Store indices\n    \n    for i in range(n):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            prev_index = stack.pop()\n            answer[prev_index] = i - prev_index\n        \n        stack.append(i)\n    \n    return answer
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def dailyTemperatures(temperatures):\n    n = len(temperatures)\n    answer = [0] * n\n    stack = []  # Store indices\n    \n    for i in range(n):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            prev_index = stack.pop()\n            answer[prev_index] = i - prev_index\n        \n        stack.append(i)\n    \n    return answer
```"
    },
    {
        "type": "radiogroup",
        "name": "q8",
        "title": "**Two Pointers Pattern - Container With Most Water**\n\nGiven `n` non-negative integers `height` where each represents a point at coordinate `(i, height[i])`. Find two lines that together with the x-axis forms a container that contains the most water.\n\n**Example:** `height = [1,8,6,2,5,4,8,3,7]` → `49`\n\n**What is the optimal Python solution using two pointers?**",
        "choices": [
            "```python
def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        width = right - left\n        current_water = width * min(height[left], height[right])\n        max_water = max(max_water, current_water)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        width = right - left\n        current_water = width * min(height[left], height[right])\n        max_water = max(max_water, current_water)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water
```"
    },
    {
        "type": "radiogroup",
        "name": "q9",
        "title": "**Tree Pattern - Validate Binary Search Tree**\n\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as: left subtree contains only nodes with keys less than the node's key, right subtree contains only nodes with keys greater than the node's key.\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python
def isValidBST(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and \n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def isValidBST(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and \n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))
```"
    },
    {
        "type": "radiogroup",
        "name": "q10",
        "title": "**Sliding Window Pattern - Minimum Window Substring**\n\nGiven two strings `s` and `t`, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window.\n\n**Example:** `s = \"ADOBECODEBANC\", t = \"ABC\"` → `\"BANC\"`\n\n**What is the optimal Python solution using sliding window?**",
        "choices": [
            "```python
from collections import Counter\n\ndef minWindow(s, t):\n    if not s or not t:\n        return \"\"\n    \n    dict_t = Counter(t)\n    required = len(dict_t)\n    formed = 0\n    window_counts = {}\n    \n    left = right = 0\n    ans = float(\"inf\"), None, None\n    \n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            character = s[left]\n            \n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
from collections import Counter\n\ndef minWindow(s, t):\n    if not s or not t:\n        return \"\"\n    \n    dict_t = Counter(t)\n    required = len(dict_t)\n    formed = 0\n    window_counts = {}\n    \n    left = right = 0\n    ans = float(\"inf\"), None, None\n    \n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            character = s[left]\n            \n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]
```"
    },
    {
        "type": "radiogroup",
        "name": "q11",
        "title": "**Heap Pattern - Find Median from Data Stream**\n\nDesign a data structure that supports adding integers and finding the median in constant time.\n\n**What is the optimal Python solution using two heaps?**",
        "choices": [
            "```python
import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max heap (negate values)\n        self.large = []  # min heap\n    \n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        \n        # Ensure every num in small <= every num in large\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        \n        # Balance the heaps\n        if len(self.small) < len(self.large):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max heap (negate values)\n        self.large = []  # min heap\n    \n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        \n        # Ensure every num in small <= every num in large\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        \n        # Balance the heaps\n        if len(self.small) < len(self.large):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0
```"
    },
    {
        "type": "radiogroup",
        "name": "q12",
        "title": "**Tree Pattern - Lowest Common Ancestor of Binary Tree**\n\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. The LCA is the lowest node that has both nodes as descendants.\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python
def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    \n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    \n    if left and right:\n        return root\n    \n    return left or right
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    \n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    \n    if left and right:\n        return root\n    \n    return left or right
```"
    },
    {
        "type": "radiogroup",
        "name": "q13",
        "title": "**Graph/BFS Pattern - Word Ladder**\n\nGiven two words `beginWord` and `endWord`, and a dictionary `wordList`, return the length of shortest transformation sequence from `beginWord` to `endWord`, changing only one letter at a time.\n\n**Example:** `beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]` → `5`\n\n**What is the optimal Python solution using BFS?**",
        "choices": [
            "```python
from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList:\n        return 0\n    \n    # Create pattern dictionary\n    neighbors = defaultdict(list)\n    wordList.append(beginWord)\n    \n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j+1:]\n            neighbors[pattern].append(word)\n    \n    visited = set([beginWord])\n    queue = deque([beginWord])\n    level = 1\n    \n    while queue:\n        for _ in range(len(queue)):\n            word = queue.popleft()\n            \n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j+1:]\n                \n                for neighbor_word in neighbors[pattern]:\n                    if neighbor_word == endWord:\n                        return level + 1\n                    \n                    if neighbor_word not in visited:\n                        visited.add(neighbor_word)\n                        queue.append(neighbor_word)\n        \n        level += 1\n    \n    return 0
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList:\n        return 0\n    \n    # Create pattern dictionary\n    neighbors = defaultdict(list)\n    wordList.append(beginWord)\n    \n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j+1:]\n            neighbors[pattern].append(word)\n    \n    visited = set([beginWord])\n    queue = deque([beginWord])\n    level = 1\n    \n    while queue:\n        for _ in range(len(queue)):\n            word = queue.popleft()\n            \n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j+1:]\n                \n                for neighbor_word in neighbors[pattern]:\n                    if neighbor_word == endWord:\n                        return level + 1\n                    \n                    if neighbor_word not in visited:\n                        visited.add(neighbor_word)\n                        queue.append(neighbor_word)\n        \n        level += 1\n    \n    return 0
```"
    },
    {
        "type": "radiogroup",
        "name": "q14",
        "title": "**Dynamic Programming Pattern - Longest Increasing Subsequence**\n\nGiven an integer array `nums`, return the length of the longest strictly increasing subsequence.\n\n**Example:** `nums = [10,9,2,5,3,7,101,18]` → `4` (subsequence [2,3,7,18])\n\n**What is the optimal Python solution using binary search + DP?**",
        "choices": [
            "```python
import bisect\n\ndef lengthOfLIS(nums):\n    tails = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        \n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
import bisect\n\ndef lengthOfLIS(nums):\n    tails = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        \n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)
```"
    },
    {
        "type": "radiogroup",
        "name": "q15",
        "title": "**Backtracking Pattern - Generate Parentheses**\n\nGiven `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n**Example:** `n = 3` → `[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]`\n\n**What is the optimal Python solution using backtracking?**",
        "choices": [
            "```python
def generateParenthesis(n):\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        if open_count < n:\n            backtrack(current + \"(\", open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(current + \")\", open_count, close_count + 1)\n    \n    backtrack(\"\", 0, 0)\n    return result
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def generateParenthesis(n):\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        if open_count < n:\n            backtrack(current + \"(\", open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(current + \")\", open_count, close_count + 1)\n    \n    backtrack(\"\", 0, 0)\n    return result
```"
    },
    {
        "type": "radiogroup",
        "name": "q16",
        "title": "**Prefix Sum Pattern - Product of Array Except Self**\n\nGiven an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must write an algorithm that runs in O(n) time and without using the division operation.\n\n**Example:** `nums = [1,2,3,4]` → `[24,12,8,6]`\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python
def productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    # Left pass\n    for i in range(1, n):\n        answer[i] = answer[i-1] * nums[i-1]\n    \n    # Right pass\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        answer[i] *= right_product\n        right_product *= nums[i]\n    \n    return answer
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    # Left pass\n    for i in range(1, n):\n        answer[i] = answer[i-1] * nums[i-1]\n    \n    # Right pass\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        answer[i] *= right_product\n        right_product *= nums[i]\n    \n    return answer
```"
    },
    {
        "type": "radiogroup",
        "name": "q17",
        "title": "**Tree Pattern - Binary Tree Maximum Path Sum**\n\nGiven the root of a binary tree, return the maximum path sum of any non-empty path. A path can start and end at any node in the tree.\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python
def maxPathSum(root):\n    max_sum = float('-inf')\n    \n    def max_gain(node):\n        nonlocal max_sum\n        \n        if not node:\n            return 0\n        \n        left_gain = max(max_gain(node.left), 0)\n        right_gain = max(max_gain(node.right), 0)\n        \n        price_newpath = node.val + left_gain + right_gain\n        max_sum = max(max_sum, price_newpath)\n        \n        return node.val + max(left_gain, right_gain)\n    \n    max_gain(root)\n    return max_sum
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def maxPathSum(root):\n    max_sum = float('-inf')\n    \n    def max_gain(node):\n        nonlocal max_sum\n        \n        if not node:\n            return 0\n        \n        left_gain = max(max_gain(node.left), 0)\n        right_gain = max(max_gain(node.right), 0)\n        \n        price_newpath = node.val + left_gain + right_gain\n        max_sum = max(max_sum, price_newpath)\n        \n        return node.val + max(left_gain, right_gain)\n    \n    max_gain(root)\n    return max_sum
```"
    },
    {
        "type": "radiogroup",
        "name": "q18",
        "title": "**Two Pointers Pattern - 3Sum**\n\nGiven an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\n**Example:** `nums = [-1,0,1,2,-1,-4]` → `[[-1,-1,2],[-1,0,1]]`\n\n**What is the optimal Python solution using two pointers?**",
        "choices": [
            "```python
def threeSum(nums):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum < 0:\n                left += 1\n            elif current_sum > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n    \n    return result
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def threeSum(nums):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum < 0:\n                left += 1\n            elif current_sum > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n    \n    return result
```"
    },
    {
        "type": "radiogroup",
        "name": "q19",
        "title": "**Graph/DFS Pattern - Number of Islands**\n\nGiven an `m x n` 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\n**What is the optimal Python solution using DFS?**",
        "choices": [
            "```python
def numIslands(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '0'):\n            return\n        \n        grid[r][c] = '0'  # Mark as visited\n        \n        # Explore all 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                islands += 1\n                dfs(r, c)\n    \n    return islands
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
def numIslands(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '0'):\n            return\n        \n        grid[r][c] = '0'  # Mark as visited\n        \n        # Explore all 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                islands += 1\n                dfs(r, c)\n    \n    return islands
```"
    },
    {
        "type": "radiogroup",
        "name": "q20",
        "title": "**Sliding Window Pattern - Permutation in String**\n\nGiven two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`. A permutation is a rearrangement of characters.\n\n**Example:** `s1 = \"ab\", s2 = \"eidbaooo\"` → `true`\n\n**What is the optimal Python solution using sliding window?**",
        "choices": [
            "```python
from collections import Counter\n\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = Counter(s1)\n    window_count = Counter()\n    \n    left = 0\n    \n    for right in range(len(s2)):\n        window_count[s2[right]] += 1\n        \n        if right - left + 1 == len(s1):\n            if window_count == s1_count:\n                return True\n            \n            window_count[s2[left]] -= 1\n            if window_count[s2[left]] == 0:\n                del window_count[s2[left]]\n            left += 1\n    \n    return False
```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python
from collections import Counter\n\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = Counter(s1)\n    window_count = Counter()\n    \n    left = 0\n    \n    for right in range(len(s2)):\n        window_count[s2[right]] += 1\n        \n        if right - left + 1 == len(s1):\n            if window_count == s1_count:\n                return True\n            \n            window_count[s2[left]] -= 1\n            if window_count[s2[left]] == 0:\n                del window_count[s2[left]]\n            left += 1\n    \n    return False
```"
    }
]