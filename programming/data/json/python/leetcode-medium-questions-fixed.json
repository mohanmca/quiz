[
    {
        "type": "radiogroup",
        "questionType": "source-code",
        "name": "q1",
        "title": "**Stack Pattern - Valid Parentheses with Multiple Types**\n\nGiven a string containing '(', ')', '{', '}', '[' and ']', determine if the input string is valid. Opening brackets must be closed by the same type of brackets and in the correct order.\n\n**Example:** `s = \"([{}])\"` → `True`\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python\ndef isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack\n```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python\ndef isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack\n```"
    },
    {
        "type": "radiogroup",
        "questionType": "source-code",
        "name": "q2",
        "title": "**Sliding Window Pattern - Longest Substring Without Repeating Characters**\n\nGiven a string `s`, find the length of the longest substring without repeating characters.\n\n**Example:** `s = \"abcabcbb\"` → `3` (\"abc\")\n\n**What is the optimal Python solution using sliding window?**",
        "choices": [
            "```python\ndef lengthOfLongestSubstring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python\ndef lengthOfLongestSubstring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n```"
    },
    {
        "type": "radiogroup",
        "questionType": "source-code",
        "name": "q3",
        "title": "**Heap Pattern - Top K Frequent Elements**\n\nGiven an integer array `nums` and an integer `k`, return the `k` most frequent elements.\n\n**Example:** `nums = [1,1,1,2,2,3], k = 2` → `[1,2]`\n\n**What is the optimal Python solution using heap?**",
        "choices": [
            "```python\nimport heapq\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)\n```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python\nimport heapq\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)\n```"
    },
    {
        "type": "radiogroup",
        "questionType": "source-code",
        "name": "q4",
        "title": "**Tree Pattern - Binary Tree Level Order Traversal**\n\nGiven the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).\n\n**Example:** `[3,9,20,null,null,15,7]` → `[[3],[9,20],[15,7]]`\n\n**What is the optimal Python solution?**",
        "choices": [
            "```python\nfrom collections import deque\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result\n```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python\nfrom collections import deque\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result\n```"
    },
    {
        "type": "radiogroup",
        "questionType": "source-code",
        "name": "q5",
        "title": "**DAG Pattern - Course Schedule**\n\nThere are `numCourses` courses labeled from 0 to `numCourses - 1`. Given prerequisites array where `prerequisites[i] = [ai, bi]` indicates you must take course `bi` first to take course `ai`. Return `true` if you can finish all courses.\n\n**Example:** `numCourses = 2, prerequisites = [[1,0]]` → `true`\n\n**What is the optimal Python solution using topological sort?**",
        "choices": [
            "```python\nfrom collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    completed = 0\n    \n    while queue:\n        current = queue.popleft()\n        completed += 1\n        \n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return completed == numCourses\n```",
            "NA1",
            "NA2"
        ],
        "correctAnswer": "```python\nfrom collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    completed = 0\n    \n    while queue:\n        current = queue.popleft()\n        completed += 1\n        \n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return completed == numCourses\n```"
    }
]
