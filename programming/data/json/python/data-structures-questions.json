[
    {
        "type": "radiogroup",
        "name": "q1",
        "title": "Which Python data structure is best for implementing a queue with O(1) enqueue and dequeue operations?",
        "choices": [
            "collections.deque",
            "list",
            "tuple",
            "set"
        ],
        "correctAnswer": "collections.deque"
    },
    {
        "type": "radiogroup",
        "name": "q2",
        "title": "What is the time complexity of checking if an element exists in a Python set?",
        "choices": [
            "O(1) average case",
            "O(log n)",
            "O(n)",
            "O(n log n)"
        ],
        "correctAnswer": "O(1) average case"
    },
    {
        "type": "radiogroup",
        "name": "q3",
        "title": "Which data structure would you use to implement a LRU (Least Recently Used) cache efficiently?",
        "choices": [
            "OrderedDict + custom logic",
            "Regular dictionary only",
            "List of tuples",
            "Set with timestamps"
        ],
        "correctAnswer": "OrderedDict + custom logic"
    },
    {
        "type": "radiogroup",
        "name": "q4",
        "title": "What is the time complexity of list.insert(0, item) in Python?",
        "choices": [
            "O(n)",
            "O(1)",
            "O(log n)",
            "O(n log n)"
        ],
        "correctAnswer": "O(n)"
    },
    {
        "type": "radiogroup",
        "name": "q5",
        "title": "Which Python module provides a min-heap implementation?",
        "choices": [
            "heapq",
            "collections",
            "bisect",
            "itertools"
        ],
        "correctAnswer": "heapq"
    },
    {
        "type": "radiogroup",
        "name": "q6",
        "title": "What does collections.Counter() return when you call most_common(1) on it?",
        "choices": [
            "A list of tuples with (element, count)",
            "Just the most common element",
            "A dictionary",
            "A set"
        ],
        "correctAnswer": "A list of tuples with (element, count)"
    },
    {
        "type": "radiogroup",
        "name": "q7",
        "title": "Which approach is most efficient for finding all anagrams in a list of strings?",
        "choices": [
            "Group by sorted string as key in a dictionary",
            "Compare each string with every other string",
            "Use nested loops with character counting",
            "Sort all strings and compare adjacent ones"
        ],
        "correctAnswer": "Group by sorted string as key in a dictionary"
    },
    {
        "type": "radiogroup",
        "name": "q8",
        "title": "What is the space complexity of using a set to track visited nodes in a graph traversal?",
        "choices": [
            "O(V) where V is the number of vertices",
            "O(E) where E is the number of edges",
            "O(V + E)",
            "O(1)"
        ],
        "correctAnswer": "O(V) where V is the number of vertices"
    },
    {
        "type": "radiogroup",
        "name": "q9",
        "title": "Which Python feature is most useful for implementing a sliding window technique?",
        "choices": [
            "collections.deque with maxlen parameter",
            "Regular list with append/pop",
            "Two pointers on a list",
            "Dictionary with ordered keys"
        ],
        "correctAnswer": "collections.deque with maxlen parameter"
    },
    {
        "type": "radiogroup",
        "name": "q10",
        "title": "What is the time complexity of dict.get() operation in Python?",
        "choices": [
            "O(1) average case",
            "O(log n)",
            "O(n)",
            "O(n log n)"
        ],
        "correctAnswer": "O(1) average case"
    },
    {
        "type": "radiogroup",
        "name": "q11",
        "title": "Which data structure is best for implementing a stack in Python?",
        "choices": [
            "list (using append/pop)",
            "collections.deque",
            "tuple",
            "set"
        ],
        "correctAnswer": "list (using append/pop)"
    },
    {
        "type": "radiogroup",
        "name": "q12",
        "title": "What does bisect.bisect_left() return when the target element is not found?",
        "choices": [
            "The insertion point to maintain sorted order",
            "-1",
            "None",
            "Raises an exception"
        ],
        "correctAnswer": "The insertion point to maintain sorted order"
    },
    {
        "type": "radiogroup",
        "name": "q13",
        "title": "Which approach is most efficient for implementing a Trie (prefix tree) in Python?",
        "choices": [
            "Nested dictionaries with character keys",
            "List of lists",
            "String concatenation",
            "Set of all prefixes"
        ],
        "correctAnswer": "Nested dictionaries with character keys"
    },
    {
        "type": "radiogroup",
        "name": "q14",
        "title": "What is the advantage of using frozenset over set for dictionary keys?",
        "choices": [
            "frozenset is immutable and can be used as a dictionary key",
            "frozenset is faster for lookups",
            "frozenset uses less memory",
            "frozenset supports more operations"
        ],
        "correctAnswer": "frozenset is immutable and can be used as a dictionary key"
    },
    {
        "type": "radiogroup",
        "name": "q15",
        "title": "Which pattern is most efficient for checking if a substring exists in a string?",
        "choices": [
            "Using 'in' operator",
            "Manual character by character comparison",
            "Converting to list and checking",
            "Using regular expressions for simple substring"
        ],
        "correctAnswer": "Using 'in' operator"
    },
    {
        "type": "radiogroup",
        "name": "q16",
        "title": "What is the time complexity of list.sort() in Python?",
        "choices": [
            "O(n log n)",
            "O(n²)",
            "O(n)",
            "O(log n)"
        ],
        "correctAnswer": "O(n log n)"
    },
    {
        "type": "radiogroup",
        "name": "q17",
        "title": "Which data structure is best for implementing a priority queue in Python?",
        "choices": [
            "heapq with a list",
            "sorted list",
            "regular list",
            "collections.deque"
        ],
        "correctAnswer": "heapq with a list"
    },
    {
        "type": "radiogroup",
        "name": "q18",
        "title": "What is the most efficient way to remove duplicates from a list while preserving order?",
        "choices": [
            "Use dict.fromkeys(list) or ordered set pattern",
            "Convert to set and back to list",
            "Use nested loops to check duplicates",
            "Sort first, then remove adjacent duplicates"
        ],
        "correctAnswer": "Use dict.fromkeys(list) or ordered set pattern"
    },
    {
        "type": "radiogroup",
        "name": "q19",
        "title": "Which approach is best for implementing a graph adjacency list in Python?",
        "choices": [
            "Dictionary with lists as values: {node: [neighbors]}",
            "List of lists",
            "Set of tuples",
            "Two-dimensional array"
        ],
        "correctAnswer": "Dictionary with lists as values: {node: [neighbors]}"
    },
    {
        "type": "radiogroup",
        "name": "q20",
        "title": "What is the space complexity of the two-pointer technique for array problems?",
        "choices": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n²)"
        ],
        "correctAnswer": "O(1)"
    },
    {
        "type": "radiogroup",
        "name": "q21",
        "title": "Which collections module class automatically provides default values for missing keys?",
        "choices": [
            "defaultdict",
            "OrderedDict",
            "Counter",
            "namedtuple"
        ],
        "correctAnswer": "defaultdict"
    },
    {
        "type": "radiogroup",
        "name": "q22",
        "title": "What is the time complexity of finding the maximum element in a max-heap?",
        "choices": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n log n)"
        ],
        "correctAnswer": "O(1)"
    },
    {
        "type": "radiogroup",
        "name": "q23",
        "title": "Which technique is most efficient for finding the intersection of two sorted arrays?",
        "choices": [
            "Two pointers approach",
            "Convert to sets and find intersection",
            "Nested loops",
            "Binary search for each element"
        ],
        "correctAnswer": "Two pointers approach"
    },
    {
        "type": "radiogroup",
        "name": "q24",
        "title": "What is the most memory-efficient way to generate a large sequence of numbers in Python?",
        "choices": [
            "Use generators or range() objects",
            "Create a large list with all numbers",
            "Use tuple with all numbers",
            "Use set with all numbers"
        ],
        "correctAnswer": "Use generators or range() objects"
    },
    {
        "type": "radiogroup",
        "name": "q25",
        "title": "Which data structure pattern is best for implementing a monotonic stack?",
        "choices": [
            "List with custom logic to maintain monotonic property",
            "heapq for automatic ordering",
            "collections.deque",
            "Regular dictionary"
        ],
        "correctAnswer": "List with custom logic to maintain monotonic property"
    },
    {
        "type": "radiogroup",
        "name": "q26",
        "title": "What is the most portable way to represent positive infinity without imports?",
        "choices": [
            "float('inf')",
            "math.infinity",
            "1e309",
            "sys.maxsize"
        ],
        "correctAnswer": "float('inf')"
    },
    {
        "type": "radiogroup",
        "name": "q27",
        "title": "Which statement about comparisons with infinity is TRUE?",
        "choices": [
            "All finite numbers are less than float('inf')",
            "float('inf') < 10 is True",
            "float('-inf') > -10 is True",
            "Comparisons with infinity raise TypeError"
        ],
        "correctAnswer": "All finite numbers are less than float('inf')"
    },
    {
        "type": "radiogroup",
        "name": "q28",
        "title": "How do you safely initialize distances for Dijkstra's algorithm?",
        "choices": [
            "dist = [float('inf')] * n; dist[src] = 0",
            "dist = [10**9] * n; dist[src] = 1",
            "dist = [None] * n",
            "dist = [0] * n"
        ],
        "correctAnswer": "dist = [float('inf')] * n; dist[src] = 0"
    },
    {
        "type": "radiogroup",
        "name": "q29",
        "title": "Using functools.lru_cache for recursion requires that:",
        "choices": [
            "All function arguments are hashable",
            "The function has no return value",
            "The function must be iterative",
            "maxsize must be set to a finite number"
        ],
        "correctAnswer": "All function arguments are hashable"
    },
    {
        "type": "radiogroup",
        "name": "q30",
        "title": "In an OrderedDict-based LRU cache, how do you mark a key as most recently used?",
        "choices": [
            "move_to_end(key, last=True)",
            "popitem(last=False)",
            "reversed(order)",
            "sort(keys)"
        ],
        "correctAnswer": "move_to_end(key, last=True)"
    },
    {
        "type": "radiogroup",
        "name": "q31",
        "title": "What does OrderedDict.popitem(last=False) remove?",
        "choices": [
            "The least recently used item (leftmost)",
            "The most recently used item (rightmost)",
            "A random item",
            "Raises KeyError always"
        ],
        "correctAnswer": "The least recently used item (leftmost)"
    },
    {
        "type": "radiogroup",
        "name": "q32",
        "title": "bisect_left on a sorted list returns:",
        "choices": [
            "Index of first element \u2265 target",
            "Index of last element \u2264 target",
            "-1 when not found",
            "None when not found"
        ],
        "correctAnswer": "Index of first element \u2265 target"
    },
    {
        "type": "radiogroup",
        "name": "q33",
        "title": "Time complexity of inserting with bisect.insort into a Python list is:",
        "choices": [
            "O(n)",
            "O(log n)",
            "O(1)",
            "O(n log n)"
        ],
        "correctAnswer": "O(n)"
    },
    {
        "type": "radiogroup",
        "name": "q34",
        "title": "Most succinct way to build a prefix sum array from nums:",
        "choices": [
            "[0] + list(itertools.accumulate(nums))",
            "Use sum(nums[:i]) in a loop",
            "Use math.cumsum(nums)",
            "Use numpy.cumsum without importing numpy"
        ],
        "correctAnswer": "[0] + list(itertools.accumulate(nums))"
    },
    {
        "type": "radiogroup",
        "name": "q35",
        "title": "For sliding window maximum of size k, the best structure is:",
        "choices": [
            "A deque as a monotonic queue",
            "A set",
            "A regular list with sort each step",
            "A dictionary"
        ],
        "correctAnswer": "A deque as a monotonic queue"
    },
    {
        "type": "radiogroup",
        "name": "q36",
        "title": "Opposite-end two-pointer loops typically use which condition?",
        "choices": [
            "while left < right",
            "while left <= right",
            "while left != right",
            "while True"
        ],
        "correctAnswer": "while left < right"
    },
    {
        "type": "radiogroup",
        "name": "q37",
        "title": "When scanning two arrays with pointers i and j, a common main loop is:",
        "choices": [
            "while i < len(arr1) and j < len(arr2)",
            "while i < len(arr1) or j < len(arr2)",
            "for i in range(len(arr1))",
            "while True"
        ],
        "correctAnswer": "while i < len(arr1) and j < len(arr2)"
    },
    {
        "type": "radiogroup",
        "name": "q38",
        "title": "Efficient way to build a large string from characters is:",
        "choices": [
            "Collect in a list then ''.join(list)",
            "Repeated '+=' concatenation",
            "Format strings in a loop",
            "Write to a file and read back"
        ],
        "correctAnswer": "Collect in a list then ''.join(list)"
    },
    {
        "type": "radiogroup",
        "name": "q39",
        "title": "Fast/slow pointer loop guard on a singly linked list is usually:",
        "choices": [
            "while fast and fast.next",
            "while slow",
            "while head",
            "while fast.next.next"
        ],
        "correctAnswer": "while fast and fast.next"
    },
    {
        "type": "radiogroup",
        "name": "q40",
        "title": "After reversing a singly linked list iteratively, you should return:",
        "choices": [
            "prev",
            "head",
            "curr",
            "None"
        ],
        "correctAnswer": "prev"
    },
    {
        "type": "radiogroup",
        "name": "q41",
        "title": "In prefix-sum + hashmap for subarray sum = k, initialize:",
        "choices": [
            "counts[0] = 1",
            "counts[1] = 0",
            "counts[k] = 1",
            "counts = {}  # empty"
        ],
        "correctAnswer": "counts[0] = 1"
    },
    {
        "type": "radiogroup",
        "name": "q42",
        "title": "To maintain a monotonically decreasing stack, pop while:",
        "choices": [
            "stack[-1] < x",
            "stack[-1] > x",
            "stack[-1] == x",
            "never pop"
        ],
        "correctAnswer": "stack[-1] < x"
    },
    {
        "type": "radiogroup",
        "name": "q43",
        "title": "In BFS level order, the number of nodes at current level is:",
        "choices": [
            "len(queue)",
            "queue[0]",
            "sum(queue)",
            "a constant"
        ],
        "correctAnswer": "len(queue)"
    },
    {
        "type": "radiogroup",
        "name": "q44",
        "title": "When pushing neighbors in graph traversal, add to 'seen':",
        "choices": [
            "Immediately when enqueuing/pushing",
            "Only when popping",
            "After processing all neighbors",
            "Never; rely on queue"
        ],
        "correctAnswer": "Immediately when enqueuing/pushing"
    },
    {
        "type": "radiogroup",
        "name": "q45",
        "title": "Maintaining top-k largest with a min-heap, you pop when:",
        "choices": [
            "len(heap) > k",
            "len(heap) >= 1",
            "the next element is smaller",
            "at the end only"
        ],
        "correctAnswer": "len(heap) > k"
    },
    {
        "type": "radiogroup",
        "name": "q46",
        "title": "upper_bound on a sorted list returns the first index where:",
        "choices": [
            "a[i] > target",
            "a[i] >= target",
            "a[i] == target",
            "a[i] < target"
        ],
        "correctAnswer": "a[i] > target"
    },
    {
        "type": "radiogroup",
        "name": "q47",
        "title": "Binary search on answer (min feasible): when check(mid) is True, update:",
        "choices": [
            "right = mid - 1",
            "left = mid + 1",
            "return mid",
            "swap left and right"
        ],
        "correctAnswer": "right = mid - 1"
    },
    {
        "type": "radiogroup",
        "name": "q48",
        "title": "Backtracking requires this step after recursion:",
        "choices": [
            "Undo the choice (backtrack)",
            "Recompute prefix sums",
            "Sort the input",
            "Recreate the stack"
        ],
        "correctAnswer": "Undo the choice (backtrack)"
    },
    {
        "type": "radiogroup",
        "name": "q49",
        "title": "Memoized DP should first:",
        "choices": [
            "Return memo[state] if present",
            "Compute the full recursion first",
            "Iterate bottom-up",
            "Clear the memo"
        ],
        "correctAnswer": "Return memo[state] if present"
    },
    {
        "type": "radiogroup",
        "name": "q50",
        "title": "In a Trie, children are commonly stored as:",
        "choices": [
            "A dict mapping char -> node",
            "A flat list of nodes",
            "A set of characters",
            "A single string"
        ],
        "correctAnswer": "A dict mapping char -> node"
    },
    {
        "type": "radiogroup",
        "name": "q51",
        "title": "Dijkstra: when popped (dist, u) has dist > recorded[u], you should:",
        "choices": [
            "continue (skip stale entry)",
            "update recorded[u] to dist",
            "clear the heap",
            "break"
        ],
        "correctAnswer": "continue (skip stale entry)"
    },
    {
        "type": "radiogroup",
        "name": "q52",
        "title": "Coin Change (min coins) backtracking base case when amount == 0 returns:",
        "choices": [
            "0",
            "-1",
            "float('inf')",
            "1"
        ],
        "correctAnswer": "0"
    },
    {
        "type": "radiogroup",
        "name": "q53",
        "title": "Which step is essential in backtracking but typically unnecessary in plain tree DFS?",
        "choices": [
            "Undoing the last choice to restore state",
            "Marking nodes as visited to avoid cycles",
            "Using a queue for level order",
            "Computing prefix sums beforehand"
        ],
        "correctAnswer": "Undoing the last choice to restore state"
    },
    {
        "type": "radiogroup",
        "name": "q54",
        "title": "Backtracking is best described as:",
        "choices": [
            "Exploring a search space by making choices, pruning, and undoing",
            "A linear scan over an array",
            "A shortest path algorithm using a priority queue",
            "A divide-and-conquer sort"
        ],
        "correctAnswer": "Exploring a search space by making choices, pruning, and undoing"
    },
  {
    "type": "radiogroup",
    "name": "q55",
    "title": "To generate all subsets of nums, which template fits?",
        "choices": [
            "Backtracking with path append then path.pop()",
            "BFS with a queue only",
            "Tree DFS sum aggregation",
            "Union-Find merges"
        ],
    "correctAnswer": "Backtracking with path append then path.pop()"
    },
    {
        "type": "radiogroup",
        "name": "q56",
        "title": "Bucket/top-k frequency trick groups by:",
        "choices": [
            "Count of occurrences (frequency)",
            "Array index modulo k",
            "Value parity",
            "Prefix sums"
        ],
        "correctAnswer": "Count of occurrences (frequency)"
    },
    {
        "type": "radiogroup",
        "name": "q57",
        "title": "Bucket sort is most appropriate when:",
        "choices": [
            "The value range is small/known",
            "The array is linked-list based",
            "Values are arbitrary floats with huge range",
            "Data is already sorted"
        ],
        "correctAnswer": "The value range is small/known"
    },
    {
        "type": "radiogroup",
        "name": "q58",
        "title": "LSD radix sort as used here assumes:",
        "choices": [
            "Non-negative integers",
            "Arbitrary Python objects",
            "Negative and positive floats",
            "Strings of varying length only"
        ],
        "correctAnswer": "Non-negative integers"
    },
    {
        "type": "radiogroup",
        "name": "q59",
        "title": "Radix sort’s per-digit step relies on a stable:",
        "choices": [
            "Counting sort",
            "Quicksort",
            "Heapsort",
            "Selection sort"
        ],
        "correctAnswer": "Counting sort"
    },
    {
        "type": "radiogroup",
        "name": "q60",
        "title": "Cyclic sort works best for arrays containing:",
        "choices": [
            "Numbers in 1..n (or 0..n-1)",
            "Arbitrary strings",
            "Sorted floating points",
            "Sparse dict keys"
        ],
        "correctAnswer": "Numbers in 1..n (or 0..n-1)"
    },
    {
        "type": "radiogroup",
        "name": "q61",
        "title": "Greedy interval scheduling chooses intervals sorted by:",
        "choices": [
            "Earliest finish time",
            "Longest duration",
            "Earliest start time",
            "Largest gap"
        ],
        "correctAnswer": "Earliest finish time"
    },
    {
        "type": "radiogroup",
        "name": "q62",
        "title": "A common way to justify a greedy algorithm is:",
        "choices": [
            "Exchange argument showing local choice can replace optimal’s",
            "Comparing average case runtimes",
            "Random testing",
            "Brute-forcing small inputs only"
        ],
        "correctAnswer": "Exchange argument showing local choice can replace optimal’s"
    },
  {
    "type": "radiogroup",
    "name": "q63",
    "title": "Meeting rooms (min rooms) solution commonly uses:",
        "choices": [
            "Two-pointer sweep over sorted starts/ends",
            "Union-Find",
            "Trie",
            "Binary Indexed Tree"
        ],
    "correctAnswer": "Two-pointer sweep over sorted starts/ends"
    },
    {
        "type": "radiogroup",
        "name": "q64",
        "title": "Union-Find initialization typically sets:",
        "choices": [
            "parent[i] = i for all i",
            "parent[i] = -1 for all i",
            "parent[i] = 0 for all i",
            "parent is left uninitialized"
        ],
        "correctAnswer": "parent[i] = i for all i"
    },
    {
        "type": "radiogroup",
        "name": "q65",
        "title": "Path compression in find(x) does what?",
        "choices": [
            "Flattens the tree by pointing nodes directly to the root",
            "Increases the rank of the root",
            "Always merges two sets",
            "Sorts the parent array"
        ],
        "correctAnswer": "Flattens the tree by pointing nodes directly to the root"
    },
    {
        "type": "radiogroup",
        "name": "q66",
        "title": "Union by rank/size chooses as new parent the root with:",
        "choices": [
            "Higher rank (or larger size)",
            "Lower rank",
            "Random choice",
            "Smaller index"
        ],
        "correctAnswer": "Higher rank (or larger size)"
    },
    {
        "type": "radiogroup",
        "name": "q67",
        "title": "To check connectivity between u and v you compute:",
        "choices": [
            "find(u) == find(v)",
            "parent[u] == parent[v]",
            "rank[u] == rank[v]",
            "u in parent[v]"
        ],
        "correctAnswer": "find(u) == find(v)"
    },
  {
    "type": "radiogroup",
    "name": "q68",
    "title": "With both path compression and union by rank, the amortized complexity per op is:",
        "choices": [
            "Near-constant, O(α(n))",
            "O(log n)",
            "O(n)",
            "O(n log n)"
        ],
    "correctAnswer": "Near-constant, O(α(n))"
    },
    {
        "type": "radiogroup",
        "name": "q69",
        "title": "Counting islands in a grid with DFS/BFS typically uses:",
        "choices": [
            "4-directional neighbors and marking visited",
            "8-directional only",
            "Sorting rows first",
            "Union-Find always"
        ],
        "correctAnswer": "4-directional neighbors and marking visited"
    },
    {
        "type": "radiogroup",
        "name": "q70",
        "title": "In grid island DFS, a common in-place visited mark is:",
        "choices": [
            "Flip '1' to '0' as you visit",
            "Increment '1' to '2' only at the end",
            "Store visited in a min-heap",
            "Use a stack but never mark"
        ],
        "correctAnswer": "Flip '1' to '0' as you visit"
    },
    {
        "type": "radiogroup",
        "name": "q71",
        "title": "DSU islands solution maps (r, c) to id using:",
        "choices": [
            "r * C + c",
            "r + c",
            "r ^ c",
            "hash((r,c))"
        ],
        "correctAnswer": "r * C + c"
    },
    {
        "type": "radiogroup",
        "name": "q72",
        "title": "Shortest Bridge strategy between two islands is to:",
        "choices": [
            "Mark one island, then multi-source BFS over water until hitting the other",
            "Run Dijkstra on all cells",
            "Use union-find only",
            "Sort cells by value and connect greedily"
        ],
        "correctAnswer": "Mark one island, then multi-source BFS over water until hitting the other"
    },
    {
        "type": "radiogroup",
        "name": "q73",
        "title": "For shortest bridge BFS, the answer equals:",
        "choices": [
            "Number of BFS expansion layers before touching the second island",
            "Total number of land cells",
            "Manhattan distance between island centroids",
            "Sum of row and column sizes"
        ],
        "correctAnswer": "Number of BFS expansion layers before touching the second island"
    }
]
