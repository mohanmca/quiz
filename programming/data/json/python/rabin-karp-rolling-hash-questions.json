[
  {"title":"What is the main idea behind the Rabin–Karp string search algorithm?","choices":["Compare pattern to every window character-by-character","Use a rolling hash to compare numeric fingerprints first","Build a suffix array to search substrings","Use dynamic programming to compute edit distance"],"correctAnswer":"Use a rolling hash to compare numeric fingerprints first"},
  {"title":"Which property makes Rabin–Karp efficient on average?","choices":["Greedy window expansion","Amortized O(1) rolling hash update","Divide-and-conquer substring splitting","Prefix-function reuse"],"correctAnswer":"Amortized O(1) rolling hash update"},
  {"title":"Common polynomial rolling hash for s[0..m-1] is:","choices":["H = sum(s[i] * base^i) mod M","H = product(s[i] + base^i) mod M","H = xor(s[i] << i) mod M","H = sum(i * s[i]) mod M"],"correctAnswer":"H = sum(s[i] * base^i) mod M"},
  {"title":"Why use modulus M (large prime)?","choices":["Avoid overflow and spread hash values","Speed up bitwise operations","Guarantee collision-free hashing","Avoid need for base"],"correctAnswer":"Avoid overflow and spread hash values"},
  {"title":"Why use a base in polynomial hash?","choices":["Convert characters to ASCII","Weigh character positions differently","Make hashing commutative","Remove need for modulus"],"correctAnswer":"Weigh character positions differently"},
  {"title":"Good base for 'a'..'z' is:","choices":["2","26 or ~31","10","1000"],"correctAnswer":"26 or ~31"},
  {"title":"Good base for general bytes is:","choices":["26","128 or 256","10","7"],"correctAnswer":"128 or 256"},
  {"title":"Collision handling in Rabin–Karp:","choices":["Impossible","Verify candidate windows with exact compare","Modulus detects all collisions","Ignore because rare"],"correctAnswer":"Verify candidate windows with exact compare"},
  {"title":"Rolling update for right slide (length m):","choices":["H' = H + base^(m-1)*s_in - s_out","H' = (H - s_out*base^(m-1)) * base + s_in (mod M)","H' = H / base + s_in - s_out","H' = H xor s_out xor s_in"],"correctAnswer":"H' = (H - s_out*base^(m-1)) * base + s_in (mod M)"},
  {"title":"Handling negatives after subtraction under mod:","choices":["Ignore negatives","Add M before % M again","Multiply by base","Set to zero"],"correctAnswer":"Add M before % M again"},
  {"title":"Worst-case time for Rabin–Karp (n text, m pattern):","choices":["O(n)","O(n log n)","O(n + m)","O(nm) when many collisions"],"correctAnswer":"O(nm) when many collisions"},
  {"title":"Expected average-case for single pattern:","choices":["O(n/m)","O(n)","O(m)","O(log n)"],"correctAnswer":"O(n)"},
  {"title":"Why precompute base^(m-1) % M?","choices":["To quickly remove outgoing char contribution","To avoid computing modulus","To make base smaller","To increase collisions"],"correctAnswer":"To quickly remove outgoing char contribution"},
  {"title":"Typical character mapping is:","choices":["Direct Unicode code point only","ASCII or small offset like ord(c)-96","Random per character","Hash(\"char\")"],"correctAnswer":"ASCII or small offset like ord(c)-96"},
  {"title":"Good choices for modulus M:","choices":["Small composites like 1000","Large primes ~1e9+7 or 1e9+9","Always power of two","Zero (no modulus)"],"correctAnswer":"Large primes ~1e9+7 or 1e9+9"},
  {"title":"Double hashing means:","choices":["Two patterns with one hash","Two (base, M) pairs to reduce collisions","Hash each character twice","Use MD5 with polynomial hash"],"correctAnswer":"Two (base, M) pairs to reduce collisions"},
  {"title":"When is Rabin–Karp especially attractive?","choices":["Single pattern in collision-heavy text","Many patterns of same length against one text","Very small patterns only","Real-time streaming without hashing"],"correctAnswer":"Many patterns of same length against one text"},
  {"title":"Use-case best suited for Rabin–Karp:","choices":["Edit distance search","Plagiarism detection via shingles","Single exact find in editor","Approximate regex matching"],"correctAnswer":"Plagiarism detection via shingles"},
  {"title":"DNA k-mers mapping typically uses:","choices":["A→1, C→2, G→3, T→4 (base 5)","A→0, C→1, G→2, T→3 (base 4)","ASCII codes (base 256)","Random primes per nucleotide"],"correctAnswer":"A→0, C→1, G→2, T→3 (base 4)"},
  {"title":"Benefit of base-4 rolling hash for DNA k-mers:","choices":["No need to verify","O(1) window updates with tiny alphabet","Collision-free hashes","Better than KMP always"],"correctAnswer":"O(1) window updates with tiny alphabet"},
  {"title":"Multi-pattern with Rabin–Karp works best when:","choices":["Patterns have different lengths","Patterns have equal length","Text is shorter than patterns","Using no modulus"],"correctAnswer":"Patterns have equal length"},
  {"title":"KMP overall worst-case time for text n, pattern m:","choices":["O(nm)","O(n + m)","O(n log m)","O(m^2)"],"correctAnswer":"O(n + m)"},
  {"title":"Core KMP preprocessing builds:","choices":["Suffix array","Failure (LPS) table","Hash set of windows","Trie of patterns"],"correctAnswer":"Failure (LPS) table"},
  {"title":"KMP is typically preferred for:","choices":["One pattern against a large text","Many equal-length patterns","Approximate substring search","Plagiarism shingle matching"],"correctAnswer":"One pattern against a large text"},
  {"title":"Contrast: collisions in RK vs KMP:","choices":["Neither has collisions","Only RK can collide; KMP doesn't hash","Both may collide often","Only KMP collides"],"correctAnswer":"Only RK can collide; KMP doesn't hash"},
  {"title":"Comparing preprocessing cost:","choices":["RK: none; KMP: none","RK: powers/hash; KMP: LPS table","RK: suffix tree; KMP: suffix array","Both require Aho–Corasick"],"correctAnswer":"RK: powers/hash; KMP: LPS table"},
  {"title":"Memory comparison:","choices":["RK needs O(m) always; KMP O(1)","RK O(1) (plus optional sets); KMP O(m)","RK O(n); KMP O(n)","Both O(mn)"],"correctAnswer":"RK O(1) (plus optional sets); KMP O(m)"},
  {"title":"Why verify after RK hash match?","choices":["To handle negative numbers","To confirm true match due to possible collisions","To compute LPS","To remove need for modulus"],"correctAnswer":"To confirm true match due to possible collisions"},
  {"title":"Technique to further reduce RK collisions:","choices":["Use base 1","Use larger window only","Double hashing with independent (base, M)","Skip verification"],"correctAnswer":"Double hashing with independent (base, M)"},
  {"title":"Which algorithm handles many patterns with varying lengths best?","choices":["Single-pattern KMP","Rabin–Karp without hashing","Aho–Corasick automaton","Naïve nested loops"],"correctAnswer":"Aho–Corasick automaton"}
]
