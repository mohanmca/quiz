[
  {"title":"What is the main idea behind the Rabin–Karp string search algorithm?","choices":["Compare pattern to every window character-by-character","Use a rolling hash to compare numeric fingerprints first","Build a suffix array to search substrings","Use dynamic programming to compute edit distance"],"correctAnswer":"Use a rolling hash to compare numeric fingerprints first"},
  {"title":"Which property makes Rabin–Karp efficient on average?","choices":["Greedy window expansion","Amortized O(1) rolling hash update","Divide-and-conquer substring splitting","Prefix-function reuse"],"correctAnswer":"Amortized O(1) rolling hash update"},
  {"title":"Common polynomial rolling hash for s[0..m-1] is:","choices":["H = sum(s[i] * base^i) mod M","H = product(s[i] + base^i) mod M","H = xor(s[i] << i) mod M","H = sum(i * s[i]) mod M"],"correctAnswer":"H = sum(s[i] * base^i) mod M"},
  {"title":"Why use modulus M (large prime)?","choices":["Avoid overflow and spread hash values","Speed up bitwise operations","Guarantee collision-free hashing","Avoid need for base"],"correctAnswer":"Avoid overflow and spread hash values"},
  {"title":"Why use a base in polynomial hash?","choices":["Convert characters to ASCII","Weigh character positions differently","Make hashing commutative","Remove need for modulus"],"correctAnswer":"Weigh character positions differently"},
  {"title":"Good base for 'a'..'z' is:","choices":["2","26 or ~31","10","1000"],"correctAnswer":"26 or ~31"},
  {"title":"Good base for general bytes is:","choices":["26","128 or 256","10","7"],"correctAnswer":"128 or 256"},
  {"title":"Collision handling in Rabin–Karp:","choices":["Impossible","Verify candidate windows with exact compare","Modulus detects all collisions","Ignore because rare"],"correctAnswer":"Verify candidate windows with exact compare"},
  {"title":"Rolling update for right slide (length m):","choices":["H' = H + base^(m-1)*s_in - s_out","H' = (H - s_out*base^(m-1)) * base + s_in (mod M)","H' = H / base + s_in - s_out","H' = H xor s_out xor s_in"],"correctAnswer":"H' = (H - s_out*base^(m-1)) * base + s_in (mod M)"},
  {"title":"Handling negatives after subtraction under mod:","choices":["Ignore negatives","Add M before % M again","Multiply by base","Set to zero"],"correctAnswer":"Add M before % M again"},
  {"title":"Worst-case time for Rabin–Karp (n text, m pattern):","choices":["O(n)","O(n log n)","O(n + m)","O(nm) when many collisions"],"correctAnswer":"O(nm) when many collisions"},
  {"title":"Expected average-case for single pattern:","choices":["O(n/m)","O(n)","O(m)","O(log n)"],"correctAnswer":"O(n)"},
  {"title":"Why precompute base^(m-1) % M?","choices":["To quickly remove outgoing char contribution","To avoid computing modulus","To make base smaller","To increase collisions"],"correctAnswer":"To quickly remove outgoing char contribution"},
  {"title":"Typical character mapping is:","choices":["Direct Unicode code point only","ASCII or small offset like ord(c)-96","Random per character","Hash(\"char\")"],"correctAnswer":"ASCII or small offset like ord(c)-96"},
  {"title":"Good choices for modulus M:","choices":["Small composites like 1000","Large primes ~1e9+7 or 1e9+9","Always power of two","Zero (no modulus)"],"correctAnswer":"Large primes ~1e9+7 or 1e9+9"},
  {"title":"Double hashing means:","choices":["Two patterns with one hash","Two (base, M) pairs to reduce collisions","Hash each character twice","Use MD5 with polynomial hash"],"correctAnswer":"Two (base, M) pairs to reduce collisions"},
  {"title":"When is Rabin–Karp especially attractive?","choices":["Single pattern in collision-heavy text","Many patterns of same length against one text","Very small patterns only","Real-time streaming without hashing"],"correctAnswer":"Many patterns of same length against one text"},
  {"title":"Use-case best suited for Rabin–Karp:","choices":["Edit distance search","Plagiarism detection via shingles","Single exact find in editor","Approximate regex matching"],"correctAnswer":"Plagiarism detection via shingles"},
  {"title":"DNA k-mers mapping typically uses:","choices":["A→1, C→2, G→3, T→4 (base 5)","A→0, C→1, G→2, T→3 (base 4)","ASCII codes (base 256)","Random primes per nucleotide"],"correctAnswer":"A→0, C→1, G→2, T→3 (base 4)"},
  {"title":"Benefit of base-4 rolling hash for DNA k-mers:","choices":["No need to verify","O(1) window updates with tiny alphabet","Collision-free hashes","Better than KMP always"],"correctAnswer":"O(1) window updates with tiny alphabet"},
  {"title":"Multi-pattern with Rabin–Karp works best when:","choices":["Patterns have different lengths","Patterns have equal length","Text is shorter than patterns","Using no modulus"],"correctAnswer":"Patterns have equal length"},
  {"title":"KMP overall worst-case time for text n, pattern m:","choices":["O(nm)","O(n + m)","O(n log m)","O(m^2)"],"correctAnswer":"O(n + m)"},
  {"title":"Core KMP preprocessing builds:","choices":["Suffix array","Failure (LPS) table","Hash set of windows","Trie of patterns"],"correctAnswer":"Failure (LPS) table"},
  {"title":"KMP is typically preferred for:","choices":["One pattern against a large text","Many equal-length patterns","Approximate substring search","Plagiarism shingle matching"],"correctAnswer":"One pattern against a large text"},
  {"title":"Contrast: collisions in RK vs KMP:","choices":["Neither has collisions","Only RK can collide; KMP doesn't hash","Both may collide often","Only KMP collides"],"correctAnswer":"Only RK can collide; KMP doesn't hash"},
  {"title":"Comparing preprocessing cost:","choices":["RK: none; KMP: none","RK: powers/hash; KMP: LPS table","RK: suffix tree; KMP: suffix array","Both require Aho–Corasick"],"correctAnswer":"RK: powers/hash; KMP: LPS table"},
  {"title":"Memory comparison:","choices":["RK needs O(m) always; KMP O(1)","RK O(1) (plus optional sets); KMP O(m)","RK O(n); KMP O(n)","Both O(mn)"],"correctAnswer":"RK O(1) (plus optional sets); KMP O(m)"},
  {"title":"Why verify after RK hash match?","choices":["To handle negative numbers","To confirm true match due to possible collisions","To compute LPS","To remove need for modulus"],"correctAnswer":"To confirm true match due to possible collisions"},
  {"title":"Technique to further reduce RK collisions:","choices":["Use base 1","Use larger window only","Double hashing with independent (base, M)","Skip verification"],"correctAnswer":"Double hashing with independent (base, M)"},
  {"title":"Which algorithm handles many patterns with varying lengths best?","choices":["Single-pattern KMP","Rabin–Karp without hashing","Aho–Corasick automaton","Naïve nested loops"],"correctAnswer":"Aho–Corasick automaton"},
  {"title":"Property of addition under mod M:","choices":["(a+b)%M = a%M + b","(a+b)%M = ((a%M)+(b%M))%M","(a+b)%M = (a*b)%M","No property"],"correctAnswer":"(a+b)%M = ((a%M)+(b%M))%M"},
  {"title":"Safe modular subtraction in C++/Java:","choices":["(a-b)%M","((a%M)-(b%M))%M","((a%M)-(b%M)+M)%M","No need to adjust"],"correctAnswer":"((a%M)-(b%M)+M)%M"},
  {"title":"Python modular subtraction behavior:","choices":["May be negative","Always non-negative result","Depends on base","Undefined"],"correctAnswer":"Always non-negative result"},
  {"title":"Efficient exponentiation modulo in Python:","choices":["a**e % M (O(e))","pow(a,e,M) (O(log e))","loop multiply (O(e))","use sqrt"],"correctAnswer":"pow(a,e,M) (O(log e))"},
  {"title":"When does modular inverse a^{-1} (mod M) exist?","choices":["Always","Only when a is even","When gcd(a, M) = 1","Only for prime M"],"correctAnswer":"When gcd(a, M) = 1"},
  {"title":"Computing inverse under prime M uses:","choices":["Floyd–Warshall","Dijkstra","Fermat’s little theorem a^{M-2} % M","Karatsuba"],"correctAnswer":"Fermat’s little theorem a^{M-2} % M"},
  {"title":"Best reason to prefer 1e9+7 as modulus:","choices":["Power of two","Small and fast","Large prime, fits in 32/64-bit, well-tested","Random"],"correctAnswer":"Large prime, fits in 32/64-bit, well-tested"},
  {"title":"Avoiding overflow for (a*b)%M in C++:","choices":["Use 32-bit int","Use __int128 or long double tricks","Ignore overflow","Multiply by base"],"correctAnswer":"Use __int128 or long double tricks"},
  {"title":"Why normalize after subtraction in rolling hash?","choices":["To speed up","To avoid negative before next multiply","To change base","To avoid double hashing"],"correctAnswer":"To avoid negative before next multiply"},
  {"title":"Double hashing collision probability reduces because:","choices":["Hashes become longer by concatenation","Using two independent primes/bases makes joint collision extremely unlikely","We compare fewer characters","We skip modulus"],"correctAnswer":"Using two independent primes/bases makes joint collision extremely unlikely"}
,
  {"title":"Distributivity under mod:","choices":["(a+b)*c % M = (a*c + b*c) % M","(a+b)*c % M = (a*b) % M","Does not hold","Only for prime M"],"correctAnswer":"(a+b)*c % M = (a*c + b*c) % M"},
  {"title":"Congruence definition:","choices":["a ≡ b (mod M) iff a=b","a ≡ b (mod M) iff M | (a-b)","a ≡ b (mod M) iff a*b is even","No formal definition"],"correctAnswer":"a ≡ b (mod M) iff M | (a-b)"},
  {"title":"Valid residue representatives:","choices":["Any integers","Exactly [1..M]","Exactly [0..M-1] after reduction","Only primes"],"correctAnswer":"Exactly [0..M-1] after reduction"},
  {"title":"Modular division caution:","choices":["Always valid","Valid only when divisor is coprime with M","Only when M is composite","Never valid"],"correctAnswer":"Valid only when divisor is coprime with M"},
  {"title":"nCr mod prime p typical approach:","choices":["Recompute factorial each time","Use floating division","Precompute factorials and inverse factorials","No modulus needed"],"correctAnswer":"Precompute factorials and inverse factorials"},
  {"title":"Which pow call is correct in Python for mod exp:","choices":["pow(a,e) % M","pow(a,e,M)","a**e(M)","exp(a,e,M)"],"correctAnswer":"pow(a,e,M)"}
,
  {"title":"How many windows of length m exist in a text of length n?","choices":["n/m","n-m+1","n-m","n+m"],"correctAnswer":"n-m+1"},
  {"title":"In a rolling loop where i is the index of the new rightmost char, the correct start index is:","choices":["i-m","i-m+1","i+m","i+1"],"correctAnswer":"i-m+1"},
  {"title":"Approximate per-window collision probability with prime modulus M:","choices":["~1/M","~1/√M","~log M","0"],"correctAnswer":"~1/M"},
  {"title":"With independent moduli M1 and M2, joint collision probability per window is:","choices":["~1/(M1+M2)","~1/(M1·M2)","~1/min(M1,M2)","~1"],"correctAnswer":"~1/(M1·M2)"}
]
