[
  {"type":"radiogroup","name":"q1","title":"What is the main idea behind the Rabin–Karp string search algorithm?","choices":["Compare pattern to every window character-by-character","Use a rolling hash to compare numeric fingerprints first","Build a suffix array to search substrings","Use dynamic programming to compute edit distance"],"correctAnswer":"Use a rolling hash to compare numeric fingerprints first"},
  {"type":"radiogroup","name":"q2","title":"Which property makes the Rabin–Karp algorithm efficient on average?","choices":["Greedy window expansion","Amortized O(1) rolling hash update","Divide-and-conquer substring splitting","Prefix-function reuse"],"correctAnswer":"Amortized O(1) rolling hash update"},
  {"type":"radiogroup","name":"q3","title":"In a polynomial rolling hash for a string s[0..m-1], which formula is commonly used?","choices":["H = sum(s[i] * base^i) mod M","H = product(s[i] + base^i) mod M","H = xor(s[i] << i) mod M","H = sum(i * s[i]) mod M"],"correctAnswer":"H = sum(s[i] * base^i) mod M"},
  {"type":"radiogroup","name":"q4","title":"What does the modulus M (a large prime) primarily help with?","choices":["Avoid integer overflow and spread hash values","Speed up bitwise operations","Guarantee collision-free hashing","Avoid need for base"],"correctAnswer":"Avoid integer overflow and spread hash values"},
  {"type":"radiogroup","name":"q5","title":"Why is a \"base\" used in polynomial rolling hashes?","choices":["To convert characters into ASCII","To weigh character positions differently","To make hashing commutative","To remove need for modulus"],"correctAnswer":"To weigh character positions differently"},
  {"type":"radiogroup","name":"q6","title":"For lowercase letters 'a'..'z', a common base choice is:","choices":["base = 2","base = 26 or slightly larger (e.g., 31)","base = 10","base = 1000"],"correctAnswer":"base = 26 or slightly larger (e.g., 31)"},
  {"type":"radiogroup","name":"q7","title":"For general byte text, a common base choice is:","choices":["base = 26","base = 128 or 256","base = 10","base = 7"],"correctAnswer":"base = 128 or 256"},
  {"type":"radiogroup","name":"q8","title":"Which statement about collisions in Rabin–Karp is correct?","choices":["Collisions cannot happen","Collisions may happen; verify with a direct compare on match","Collisions are detected by the modulus alone","Collisions are ignored because rare"],"correctAnswer":"Collisions may happen; verify with a direct compare on match"},
  {"type":"radiogroup","name":"q9","title":"What is the rolling update when sliding one character to the right (window length m)?","choices":["H' = H + base^(m-1) * s_in - s_out","H' = (H - s_out * base^(m-1)) * base + s_in (mod M)","H' = H / base + s_in - s_out","H' = H xor s_out xor s_in"],"correctAnswer":"H' = (H - s_out * base^(m-1)) * base + s_in (mod M)"},
  {"type":"radiogroup","name":"q10","title":"How do you handle negative values after subtraction in modular arithmetic?","choices":["Ignore negatives; they wrap automatically","Add M before applying mod again","Multiply by base","Set to zero"],"correctAnswer":"Add M before applying mod again"},
  {"type":"radiogroup","name":"q11","title":"What is the worst-case time complexity of Rabin–Karp on a text of length n and pattern of length m?","choices":["O(n)","O(n log n)","O(n + m)","O(nm) when many collisions"],"correctAnswer":"O(nm) when many collisions"},
  {"type":"radiogroup","name":"q12","title":"What is the expected average-case complexity for a single pattern search?","choices":["O(n/m)","O(n)","O(m)","O(log n)"],"correctAnswer":"O(n)"},
  {"type":"radiogroup","name":"q13","title":"Why precompute base^(m-1) mod M?","choices":["To quickly remove the outgoing char's contribution","To avoid computing modulus","To make base smaller","To increase collisions"],"correctAnswer":"To quickly remove the outgoing char's contribution"},
  {"type":"radiogroup","name":"q14","title":"Which mapping for characters is typical in implementations?","choices":["Direct Unicode code point","ASCII code or small offset (e.g., ord(c)-96)","Random integer per character","Hash of character string"],"correctAnswer":"ASCII code or small offset (e.g., ord(c)-96)"},
  {"type":"radiogroup","name":"q15","title":"What are good choices for M (modulus)?","choices":["Small composites like 1000","Large primes near 1e9+7 or 1e9+9","Always power of two","Zero (no modulus)"],"correctAnswer":"Large primes near 1e9+7 or 1e9+9"},
  {"type":"radiogroup","name":"q16","title":"What is double hashing in this context?","choices":["Using two patterns","Using two different (base, M) pairs to reduce collisions","Hashing each character twice","Using MD5 with polynomial hash"],"correctAnswer":"Using two different (base, M) pairs to reduce collisions"},
  {"type":"radiogroup","name":"q17","title":"When is Rabin–Karp especially attractive?","choices":["Single pattern search in collision-heavy data","Multiple pattern matching against the same text","Very small patterns only","Real-time streaming without hashing"],"correctAnswer":"Multiple pattern matching against the same text"},
  {"type":"radiogroup","name":"q18","title":"Given base=256, M=101, pattern length m=3, outgoing byte 97 ('a'), incoming byte 98 ('b'), and base^(m-1)=256^2 mod 101= (65536 mod 101)=? Hint: 65536 mod 101 = 65.","choices":["H' = (H - 97*65)*256 + 98 mod 101","H' = (H - 97)*256 + 98 mod 101","H' = (H/256) + 98 - 97 mod 101","H' = H xor 97 xor 98"],"correctAnswer":"H' = (H - 97*65)*256 + 98 mod 101"},
  {"type":"radiogroup","name":"q19","title":"What problem arises if base and M share factors (not coprime)?","choices":["Hash becomes always zero","Increased collision rate / poor distribution","Division by zero","Compilation error"],"correctAnswer":"Increased collision rate / poor distribution"},
  {"type":"radiogroup","name":"q20","title":"Which step confirms a match after hash equality?","choices":["No step; hash equality implies match","Random sampling characters","Character-by-character verification of the window","Bitwise xor of window"],"correctAnswer":"Character-by-character verification of the window"},
  {"type":"radiogroup","name":"q21","title":"What is the main cause of false positives in Rabin–Karp?","choices":["Hash collisions","Incorrect window size","Unicode normalization","Greedy matching"],"correctAnswer":"Hash collisions"},
  {"type":"radiogroup","name":"q22","title":"Which Python data type is typically used for character codes in hashing?","choices":["str","bytes","int from ord(c)","list"],"correctAnswer":"int from ord(c)"},
  {"type":"radiogroup","name":"q23","title":"Choose a reasonable Python base, M pair for general ASCII text:","choices":["base=256, M=10","base=256, M=1_000_000_007","base=10, M=101","base=2, M=97"],"correctAnswer":"base=256, M=1_000_000_007"},
  {"type":"radiogroup","name":"q24","title":"How to avoid negative modulo in Python when subtracting outgoing term?","choices":["Use (value % M + M) % M","Use abs(value) % M","Ignore; Python handles automatically","Add base"],"correctAnswer":"Use (value % M + M) % M"},
  {"type":"radiogroup","name":"q25","title":"What does \"rolling\" mean in rolling hash?","choices":["Recomputing from scratch for each window","Incrementally updating hash when window slides","Using recursion","Sorting characters in window"],"correctAnswer":"Incrementally updating hash when window slides"},
  {"type":"radiogroup","name":"q26","title":"Rabin–Karp handles which scenario efficiently compared to KMP?","choices":["Pattern with many wildcards across multiple patterns","Single exact match with no wildcards","Computing minimal edit distance","Finding palindromes"],"correctAnswer":"Pattern with many wildcards across multiple patterns"},
  {"type":"radiogroup","name":"q27","title":"What is a practical way to reduce collision probability without huge M?","choices":["Decrease base to 2","Use two independent hashes and require both to match","Use no modulus","Square the hash"],"correctAnswer":"Use two independent hashes and require both to match"},
  {"type":"radiogroup","name":"q28","title":"In polynomial hash, which positional exponent is commonly used for s[0] in left-to-right encoding?","choices":["base^0","base^(m-1)","base^m","base^1"],"correctAnswer":"base^(m-1)"},
  {"type":"radiogroup","name":"q29","title":"In a right-to-left encoding variant, s[m-1] often uses:","choices":["base^(m-1)","base^0","base^1","base^2"],"correctAnswer":"base^0"},
  {"type":"radiogroup","name":"q30","title":"What happens if M is too small?","choices":["No effect","Very frequent collisions","Hash becomes negative","Program crashes"],"correctAnswer":"Very frequent collisions"},
  {"type":"radiogroup","name":"q31","title":"Why do many tutorials choose M = 1_000_000_007?","choices":["Because it is a Mersenne prime","It is a large prime; reduces collisions and fits 64-bit","It's a power of two","It equals 2^32"],"correctAnswer":"It is a large prime; reduces collisions and fits 64-bit"},
  {"type":"radiogroup","name":"q32","title":"Suppose pattern length m=5. Which power must be precomputed?","choices":["base^5","base^4","base^3","base^6"],"correctAnswer":"base^4"},
  {"type":"radiogroup","name":"q33","title":"After matching hash, what is the cost of final verification?","choices":["O(1)","O(log m)","O(m)","O(n)"],"correctAnswer":"O(m)"},
  {"type":"radiogroup","name":"q34","title":"Which operation prevents overflow in languages without big ints?","choices":["Apply modulus at each step","Use floats","Use XOR instead of addition","Avoid multiplication"],"correctAnswer":"Apply modulus at each step"},
  {"type":"radiogroup","name":"q35","title":"When sliding, removing s_out requires which multiplier?","choices":["base","base^(m-1)","base^m","1/base"],"correctAnswer":"base^(m-1)"},
  {"type":"radiogroup","name":"q36","title":"If you choose base too large (e.g., 10^9), what is a downside?","choices":["No downside","Hash updates become slow and overflow risk increases","Cannot handle lowercase letters","Pattern must be very short"],"correctAnswer":"Hash updates become slow and overflow risk increases"},
  {"type":"radiogroup","name":"q37","title":"Which statement is true for Unicode text handling?","choices":["Always map to ASCII first","Use code points (ord) or normalized forms consistently","Unicode makes RK impossible","Only bytes are supported"],"correctAnswer":"Use code points (ord) or normalized forms consistently"},
  {"type":"radiogroup","name":"q38","title":"Why might you prefer base=911382323 and M=972663749 (random primes)?","choices":["For stylish numbers","To reduce adversarial collision crafting","To enable floating math","To remove need for verification"],"correctAnswer":"To reduce adversarial collision crafting"},
  {"type":"radiogroup","name":"q39","title":"What is a spurious hit?","choices":["A real match","A hash match that fails on character check","An out-of-bounds window","A segmentation fault"],"correctAnswer":"A hash match that fails on character check"},
  {"type":"radiogroup","name":"q40","title":"How to handle empty pattern (m=0) per common convention?","choices":["Return no matches","Return match at every index","Return 0 only","Raise exception"],"correctAnswer":"Return match at every index"},
  {"type":"radiogroup","name":"q41","title":"Which is a correct initial hash build for the first window of length m?","choices":["Accumulate s[i] * base^(m-1-i) modulo M","Sum s[i] without modulus","Multiply all s[i]","Sort then sum"],"correctAnswer":"Accumulate s[i] * base^(m-1-i) modulo M"},
  {"type":"radiogroup","name":"q42","title":"In Python, why keep all arithmetic under modulo M?","choices":["To use ints safely and keep distribution","To force floats","To reduce code size","To avoid loops"],"correctAnswer":"To use ints safely and keep distribution"},
  {"type":"radiogroup","name":"q43","title":"What is typical memory usage for single-pattern Rabin–Karp?","choices":["O(1) extra beyond input","O(n)","O(m^2)","O(log n)"],"correctAnswer":"O(1) extra beyond input"},
  {"type":"radiogroup","name":"q44","title":"Which choice lowers collision probability most effectively?","choices":["Smaller base","Composite modulus","Larger prime modulus and/or double hashing","No modulus"],"correctAnswer":"Larger prime modulus and/or double hashing"},
  {"type":"radiogroup","name":"q45","title":"Which is a correct rolling update step order?","choices":["Add s_in, multiply by base, subtract s_out*pow","Subtract outgoing term, multiply by base, add incoming term","Multiply by base, subtract outgoing term, add incoming term","Divide by base, add incoming term"],"correctAnswer":"Subtract outgoing term, multiply by base, add incoming term"},
  {"type":"radiogroup","name":"q46","title":"What if pattern length m > n (text length)?","choices":["Return empty result immediately","Still run rolling hash","Raise error","Pad text"],"correctAnswer":"Return empty result immediately"},
  {"type":"radiogroup","name":"q47","title":"Given base=31, M=1e9+7, m=3, chars map a=1,b=2,c=3, what is hash('abc')?","choices":["1*31^2+2*31^1+3*31^0","1*31^0+2*31^1+3*31^2","(1+2+3) mod M","(1*31 + 2*31 + 3*31) mod M"],"correctAnswer":"1*31^2+2*31^1+3*31^0"},
  {"type":"radiogroup","name":"q48","title":"Which statement about power precomputation is true?","choices":["Not needed","Useful to avoid repeated exponentiation","Only for small m","Replaces modulus"],"correctAnswer":"Useful to avoid repeated exponentiation"},
  {"type":"radiogroup","name":"q49","title":"How to handle very long texts efficiently?","choices":["Use chunked streaming with rolling hash state","Load whole text into list of ints","Always store all window hashes","Convert to set of substrings"],"correctAnswer":"Use chunked streaming with rolling hash state"},
  {"type":"radiogroup","name":"q50","title":"What does verifying candidate matches guard against?","choices":["Index errors","Floating point drift","Hash collisions and false positives","Infinite loops"],"correctAnswer":"Hash collisions and false positives"},
  {"type":"radiogroup","name":"q51","title":"Why might you normalize case (lowercase) before hashing?","choices":["To reduce alphabet size and simplify matching","To speed up multiplication","To avoid modulus","To remove spaces"],"correctAnswer":"To reduce alphabet size and simplify matching"},
  {"type":"radiogroup","name":"q52","title":"If you choose base=1, what happens?","choices":["Perfect hash","All positions equally weighted; terrible distribution","Fastest algorithm","Guaranteed collision-free"],"correctAnswer":"All positions equally weighted; terrible distribution"},
  {"type":"radiogroup","name":"q53","title":"Why do many use base slightly larger than alphabet?","choices":["To improve positional mixing and reduce accidental overlaps","To simplify code","To avoid modulus","To avoid verification"],"correctAnswer":"To improve positional mixing and reduce accidental overlaps"},
  {"type":"radiogroup","name":"q54","title":"When sliding, which values change?","choices":["Only s_out","Only s_in","Both s_out and s_in","Neither"],"correctAnswer":"Both s_out and s_in"},
  {"type":"radiogroup","name":"q55","title":"Primary difference from KMP?","choices":["RK uses hashing; KMP uses prefix function","RK uses DP; KMP uses hashing","RK sorts text; KMP hashes","RK builds suffix tree"],"correctAnswer":"RK uses hashing; KMP uses prefix function"},
  {"type":"radiogroup","name":"q56","title":"Which window length is used in rolling?","choices":["Pattern length m","1","log m","n/2"],"correctAnswer":"Pattern length m"},
  {"type":"radiogroup","name":"q57","title":"In Python, which expression safely normalizes a modulo result x after subtraction?","choices":["x = (x + M) % M","x = abs(x) % M","x = x // M","x = x & M"],"correctAnswer":"x = (x + M) % M"},
  {"type":"radiogroup","name":"q58","title":"What is the effect of choosing base too small (e.g., 2) for large alphabets?","choices":["Great distribution","Higher collision probability","Faster than usual with same collision rate","No effect"],"correctAnswer":"Higher collision probability"},
  {"type":"radiogroup","name":"q59","title":"Which best describes \"rolling\" in terms of operations?","choices":["O(m) updates","O(1) updates: one subtraction, one multiply, one add","O(log m) updates","O(n) per step"],"correctAnswer":"O(1) updates: one subtraction, one multiply, one add"},
  {"type":"radiogroup","name":"q60","title":"Why is verifying only when hashes match efficient?","choices":["Because hashes rarely match accidentally","Because verification uses bit operations only","Because no need to slide anymore","Because power precomputation avoids it"],"correctAnswer":"Because hashes rarely match accidentally"},
  {"type":"radiogroup","name":"q61","title":"Given base=256, M=101, m=3, pre=65, after removing 97 and adding 98, which adjustment ensures non-negative before %M?","choices":["Add M if intermediate becomes negative","Multiply by -1","Add base","No need to adjust"],"correctAnswer":"Add M if intermediate becomes negative"},
  {"type":"radiogroup","name":"q62","title":"Which is a correct reason to choose two large different primes for double hashing?","choices":["To allow division","To make results identical","To make collision probability approximately product of individual probabilities","To make code shorter"],"correctAnswer":"To make collision probability approximately product of individual probabilities"},
  {"type":"radiogroup","name":"q63","title":"What is a reasonable alphabet mapping for bytes?","choices":["ord(c) as 0..255","ord(c)-96 as 1..26","Hash(str(c))","Index in sorted unique set each run"],"correctAnswer":"ord(c) as 0..255"},
  {"type":"radiogroup","name":"q64","title":"Which step is NOT part of Rabin–Karp?","choices":["Compute rolling hash of windows","Compare pattern hash","Verify candidate match with direct compare","Compute Z-function of text"],"correctAnswer":"Compute Z-function of text"},
  {"type":"radiogroup","name":"q65","title":"When might you avoid modulo entirely (M=None) in Python?","choices":["Always","When using Python big ints with careful overflow control is acceptable (usually not recommended)","When base=1","When n<10"],"correctAnswer":"When using Python big ints with careful overflow control is acceptable (usually not recommended)"},
  {"type":"radiogroup","name":"q66","title":"Which edge case should be handled explicitly?","choices":["Empty text only","Empty pattern (m=0)","Text equals pattern always","Both are None"],"correctAnswer":"Empty pattern (m=0)"},
  {"type":"radiogroup","name":"q67","title":"What is the benefit of keeping powers precomputed in a list?","choices":["Faster removal of outgoing character term","Less memory","Avoid loops entirely","Guarantee unique hash"],"correctAnswer":"Faster removal of outgoing character term"},
  {"type":"radiogroup","name":"q68","title":"Which rolling-hash variant helps with 2D pattern search?","choices":["Use 2D polynomial hash (row then combine)","Use suffix array","Use BFS","Use greedy expansion"],"correctAnswer":"Use 2D polynomial hash (row then combine)"},
  {"type":"radiogroup","name":"q69","title":"In practice, why store pattern hash separately?","choices":["To recompute it each time","To compare against window hash quickly","To sort matches","To skip modulus"],"correctAnswer":"To compare against window hash quickly"},
  {"type":"radiogroup","name":"q70","title":"Rabin–Karp is especially suitable for which data structure problem?","choices":["Exact single substring search rarely","Detecting many pattern appearances across text (multi-pattern)","Balanced BST operations","Graph shortest path"],"correctAnswer":"Detecting many pattern appearances across text (multi-pattern)"},
  {"type":"radiogroup","name":"q71","title":"Python: which line updates the rolling hash correctly?\n```python\n# H is current, pre_pow is base**(m-1) % M\nH = (H - out_val * pre_pow) % M\nH = (H * base + in_val) % M\n```","choices":["As shown: subtract term, multiply, add, with modulo at each step","Multiply then subtract to simplify","Only add incoming value","Use division by base to remove outgoing"],"correctAnswer":"As shown: subtract term, multiply, add, with modulo at each step"},
  {"type":"radiogroup","name":"q72","title":"Given code, what does pre_pow represent?\n```python\npre_pow = pow(base, m-1, M)\n```","choices":["base^m mod M","base^(m-1) mod M","m^(base-1) mod M","(base-1)^m mod M"],"correctAnswer":"base^(m-1) mod M"},
  {"type":"radiogroup","name":"q73","title":"In this Python snippet, what ensures non-negative after subtraction?\n```python\nH = (H - out_val * pre_pow) % M\n```","choices":["Python auto-fixes negativity without %","The % M makes the result in [0, M) in Python","Nothing; it can stay negative","It rounds"],"correctAnswer":"The % M makes the result in [0, M) in Python"},
  {"type":"radiogroup","name":"q74","title":"Which Python snippet builds the initial hash for window s[:m]?\n```python\nH = 0\nfor i, ch in enumerate(s[:m]):\n    H = (H * base + val(ch)) % M\n```","choices":["Correct left-to-right accumulation","Incorrect; must use exponentiation only","Incorrect; must start from i=m-1","Must use floats"],"correctAnswer":"Correct left-to-right accumulation"},
  {"type":"radiogroup","name":"q75","title":"Which is a correct Python function signature for Rabin–Karp search?","choices":["def rk_search(text: str, pattern: str) -> list[int]","def rk_search(text, pattern, base, M) -> None","def rk_search() -> int","def rk_search(text: bytes) -> str"],"correctAnswer":"def rk_search(text: str, pattern: str) -> list[int]"},
  {"type":"radiogroup","name":"q76","title":"Why might you convert to bytes for general text?","choices":["To fix Unicode entirely","To standardize to 0..255 symbols across encodings","To speed up Python modulo always","To avoid hashing"],"correctAnswer":"To standardize to 0..255 symbols across encodings"},
  {"type":"radiogroup","name":"q77","title":"Which Python code compares candidate window on hash match?\n```python\nif H == Hp and text[i-m+1:i+1] == pattern:\n    res.append(i-m+1)\n```","choices":["Correct: verify substring equality","Incorrect: should compare integers only","Incorrect: slicing is O(1)","Incorrect: append i"],"correctAnswer":"Correct: verify substring equality"},
  {"type":"radiogroup","name":"q78","title":"Why use pow(base, m-1, M) in Python?","choices":["Because pow is slower","It computes modular power efficiently without overflow","It returns floats","It returns negative"],"correctAnswer":"It computes modular power efficiently without overflow"},
  {"type":"radiogroup","name":"q79","title":"Which is a safe mapping function in Python?\n```python\nval = lambda ch: (ord(ch) - 96) if ch.isalpha() else ord(ch) % 256\n```","choices":["Reasonable for mixed text","Invalid Python","Always returns negative","Returns floats"],"correctAnswer":"Reasonable for mixed text"},
  {"type":"radiogroup","name":"q80","title":"Which best describes Rabin–Karp for an intermediate programmer?","choices":["Exact matching via fast rolling fingerprints and rare verifications","Dynamic programming over substrings","Suffix automaton construction","Trie-based matching only"],"correctAnswer":"Exact matching via fast rolling fingerprints and rare verifications"}
]

