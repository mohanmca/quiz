[
  {"title":"Which statement best describes an lvalue?","choices":["A temporary without identity","An expression with persistent identity","Always a compile-time constant","A value that cannot be assigned"],"correctAnswer":1},
  {"title":"Which can bind to a temporary (prvalue) by default?","choices":["T&","const T&","volatile T&","T& only when moved"],"correctAnswer":1},
  {"title":"What does std::move do?","choices":["Moves memory","Casts to rvalue/xvalue","Copies and then deletes","Synchronizes threads"],"correctAnswer":1},
  {"title":"A temporary bound to const T& in a local scope:","choices":["Dies immediately","Has extended lifetime to the reference scope","Leads always to dangling","Becomes a static object"],"correctAnswer":1},
  {"title":"When should you write a move constructor?","choices":["Always","When type owns resources and default move is wrong/disabled","Never if copy exists","Only for PODs"],"correctAnswer":1},
  {"title":"Marking move operations noexcept helps because…","choices":["It removes all exceptions globally","Containers prefer moving over copying","It disables copy elision","It enables more RTTI"],"correctAnswer":1},
  {"title":"Return Value Optimization (RVO) in C++17 is…","choices":["Forbidden","Optional","Mandatory in certain cases (guaranteed elision)","Replaced by copy"],"correctAnswer":2},
  {"title":"Binding non-const T& to a temporary:","choices":["Allowed","Ill-formed","Implies copy elision","Creates an xvalue"],"correctAnswer":1},
  {"title":"Which is an xvalue?","choices":["42","std::move(x)","name of a variable","string literal"],"correctAnswer":1},
  {"title":"Dangling reference example:","choices":["const int& r = 42;","int& r = local_returned_by_ref();","const std::string& r = make();","binding const ref to a static"],"correctAnswer":1},
  {"title":"unique_ptr semantics:","choices":["Copyable","Movable, not copyable","Always shared","Needs manual delete"],"correctAnswer":1},
  {"title":"shared_ptr cycle occurs when…","choices":["Two objects hold shared_ptr to each other","Using custom deleter","Using make_shared","Using weak_ptr"],"correctAnswer":0},
  {"title":"weak_ptr purpose:","choices":["Owns memory","Observes without ownership","For arrays only","Replaces unique_ptr"],"correctAnswer":1},
  {"title":"Aliasing constructor of shared_ptr pitfall:","choices":["Changes control block unexpectedly","Prevents cycles","Forces unique ownership","Guarantees small object optimization"],"correctAnswer":0},
  {"title":"RAII principle:","choices":["Acquire in ctor, release in dtor","Use global new/delete","Delay cleanup to program end","Ignore exceptions"],"correctAnswer":0},
  {"title":"Custom deleter affects unique_ptr type because…","choices":["It modifies ABI","Deleter type is part of unique_ptr type","Compiler bug","All deleters are erased"],"correctAnswer":1},
  {"title":"Template partial specialization is allowed for…","choices":["Function templates","Class/alias/variable templates","Only functions","Only concepts"],"correctAnswer":1},
  {"title":"SFINAE means…","choices":["Substitution failure is not an error","Static functions inlined","Structured fold is new","Strong form of noexcept"],"correctAnswer":0},
  {"title":"Concepts improve over SFINAE by…","choices":["Runtime checks","Clearer intent and diagnostics","Slower compile times","Disabling overloads"],"correctAnswer":1},
  {"title":"Fold expression example category:","choices":["Unary fold only","Binary fold over parameter packs","No relation to packs","Linker feature"],"correctAnswer":1},
  {"title":"Use typename keyword when…","choices":["Referring to a dependent type name","Calling a function","Defining a macro","In any namespace"],"correctAnswer":0},
  {"title":"CRTP offers…","choices":["Runtime polymorphism","Static polymorphism","No polymorphism","Multiple vtables"],"correctAnswer":1},
  {"title":"constexpr enables…","choices":["Compile-time evaluation","Only run-time optimization","Dynamic linking","Disable templates"],"correctAnswer":0},
  {"title":"Object slicing occurs when…","choices":["Passing by reference","Assigning derived to base by value","Using virtual dtor","Using pointers"],"correctAnswer":1},
  {"title":"Use override to…","choices":["Hide base method","Mark intended override and catch mismatches","Force inlining","Make method final"],"correctAnswer":1},
  {"title":"Virtual inheritance solves…","choices":["Memory leaks","Diamond duplicate base subobjects","Thread safety","Move-only types"],"correctAnswer":1},
  {"title":"A pure virtual destructor…","choices":["Cannot be defined","Must still be defined","Deletes vtable","Breaks RTTI"],"correctAnswer":1},
  {"title":"Placement new is used to…","choices":["Allocate raw memory","Construct an object in pre-allocated memory","Delete arrays","Make copies"],"correctAnswer":1},
  {"title":"Pointer arithmetic is only defined…","choices":["Across any memory","Within same array/object","Across different arrays","On void*"],"correctAnswer":1},
  {"title":"const_cast should be used…","choices":["To change const objects","Rarely, to interface legacy APIs when underlying object is non-const","Often to modify const","For concurrency"],"correctAnswer":1},
  {"title":"volatile is for…","choices":["Multithreading","Memory-mapped I/O / signals","Faster code","Exceptions"],"correctAnswer":1},
  {"title":"std::variant vs union:","choices":["variant is type-safe with active index","union is always safe","variant is C-only","union auto-tracks type"],"correctAnswer":0},
  {"title":"Exception safety strong guarantee means…","choices":["Program never throws","Operation either succeeds or has no effect","No resources leak","All exceptions are caught"],"correctAnswer":1},
  {"title":"noexcept on move helps containers because…","choices":["They can avoid reallocation","They prefer move in reallocation","They delete elements","They copy instead"],"correctAnswer":1},
  {"title":"Use std::optional when…","choices":["You need error details","You need presence/absence of a value","You need exceptions","You need shared ownership"],"correctAnswer":1},
  {"title":"Lambda move capture syntax:","choices":["[&x]","[x = std::move(x)]","[this]","[=]"],"correctAnswer":1},
  {"title":"Ranges are…","choices":["Eager pipelines","Lazy views and algorithms","Macros","Only for strings"],"correctAnswer":1},
  {"title":"Coroutines use…","choices":["co_return / co_yield / co_await","goto","yield in loops only","async only"],"correctAnswer":0},
  {"title":"Modules primarily help with…","choices":["Runtime speed only","Reducing header overhead/ODR and improving builds","Replacing templates","Eliminating linking"],"correctAnswer":1},
  {"title":"Data race in C++ is…","choices":["Well-defined","Implementation-defined","Undefined behavior","Always crashes"],"correctAnswer":2},
  {"title":"Acquire-Release pair establishes…","choices":["No order","Happens-before on shared data","Linker visibility","Exception neutrality"],"correctAnswer":1},
  {"title":"std::async returns…","choices":["std::thread","std::future","std::promise","std::optional"],"correctAnswer":1},
  {"title":"CAS loops risk…","choices":["ODR violations","ABA problems","Copy elision issues","constexpr overflow"],"correctAnswer":1},
  {"title":"thread_local gives…","choices":["Shared state","Per-thread storage","Faster heap","Global lock"],"correctAnswer":1},
  {"title":"ODR violation often appears as…","choices":["Multiple definition linker error","Missing header","Runtime exception","UBSAN warning only"],"correctAnswer":0},
  {"title":"Templates typically live in…","choices":[".cpp only","Headers (or explicit instantiation)","Shared libraries only","Linker scripts"],"correctAnswer":1}
  
  
  
]

