[
  {"title":"Which statement best describes an lvalue?","choices":["A temporary without identity","An expression with persistent identity","Always a compile-time constant","A value that cannot be assigned"],"correctAnswer":1},
  {"title":"Which can bind to a temporary (prvalue) by default?","choices":["T&","const T&","volatile T&","T& only when moved"],"correctAnswer":1},
  {"title":"What does std::move do?","choices":["Moves memory","Casts to rvalue/xvalue","Copies and then deletes","Synchronizes threads"],"correctAnswer":1},
  {"title":"A temporary bound to const T& in a local scope:","choices":["Dies immediately","Has extended lifetime to the reference scope","Leads always to dangling","Becomes a static object"],"correctAnswer":1},
  {"title":"When should you write a move constructor?","choices":["Always","When type owns resources and default move is wrong/disabled","Never if copy exists","Only for PODs"],"correctAnswer":1},
  {"title":"Marking move operations noexcept helps because…","choices":["It removes all exceptions globally","Containers prefer moving over copying","It disables copy elision","It enables more RTTI"],"correctAnswer":1},
  {"title":"Return Value Optimization (RVO) in C++17 is…","choices":["Forbidden","Optional","Mandatory in certain cases (guaranteed elision)","Replaced by copy"],"correctAnswer":2},
  {"title":"Binding non-const T& to a temporary:","choices":["Allowed","Ill-formed","Implies copy elision","Creates an xvalue"],"correctAnswer":1},
  {"title":"Which is an xvalue?","choices":["42","std::move(x)","name of a variable","string literal"],"correctAnswer":1},
  {"title":"Dangling reference example:","choices":["const int& r = 42;","int& r = local_returned_by_ref();","const std::string& r = make();","binding const ref to a static"],"correctAnswer":1},
  {"title":"unique_ptr semantics:","choices":["Copyable","Movable, not copyable","Always shared","Needs manual delete"],"correctAnswer":1},
  {"title":"shared_ptr cycle occurs when…","choices":["Two objects hold shared_ptr to each other","Using custom deleter","Using make_shared","Using weak_ptr"],"correctAnswer":0},
  {"title":"weak_ptr purpose:","choices":["Owns memory","Observes without ownership","For arrays only","Replaces unique_ptr"],"correctAnswer":1},
  {"title":"Aliasing constructor of shared_ptr pitfall:","choices":["Changes control block unexpectedly","Prevents cycles","Forces unique ownership","Guarantees small object optimization"],"correctAnswer":0},
  {"title":"RAII principle:","choices":["Acquire in ctor, release in dtor","Use global new/delete","Delay cleanup to program end","Ignore exceptions"],"correctAnswer":0},
  {"title":"Custom deleter affects unique_ptr type because…","choices":["It modifies ABI","Deleter type is part of unique_ptr type","Compiler bug","All deleters are erased"],"correctAnswer":1},
  {"title":"Template partial specialization is allowed for…","choices":["Function templates","Class/alias/variable templates","Only functions","Only concepts"],"correctAnswer":1},
  {"title":"SFINAE means…","choices":["Substitution failure is not an error","Static functions inlined","Structured fold is new","Strong form of noexcept"],"correctAnswer":0},
  {"title":"Concepts improve over SFINAE by…","choices":["Runtime checks","Clearer intent and diagnostics","Slower compile times","Disabling overloads"],"correctAnswer":1},
  {"title":"Fold expression example category:","choices":["Unary fold only","Binary fold over parameter packs","No relation to packs","Linker feature"],"correctAnswer":1},
  {"title":"Use typename keyword when…","choices":["Referring to a dependent type name","Calling a function","Defining a macro","In any namespace"],"correctAnswer":0},
  {"title":"CRTP offers…","choices":["Runtime polymorphism","Static polymorphism","No polymorphism","Multiple vtables"],"correctAnswer":1},
  {"title":"constexpr enables…","choices":["Compile-time evaluation","Only run-time optimization","Dynamic linking","Disable templates"],"correctAnswer":0},
  {"title":"Object slicing occurs when…","choices":["Passing by reference","Assigning derived to base by value","Using virtual dtor","Using pointers"],"correctAnswer":1},
  {"title":"Use override to…","choices":["Hide base method","Mark intended override and catch mismatches","Force inlining","Make method final"],"correctAnswer":1},
  {"title":"Virtual inheritance solves…","choices":["Memory leaks","Diamond duplicate base subobjects","Thread safety","Move-only types"],"correctAnswer":1},
  {"title":"A pure virtual destructor…","choices":["Cannot be defined","Must still be defined","Deletes vtable","Breaks RTTI"],"correctAnswer":1},
  {"title":"Placement new is used to…","choices":["Allocate raw memory","Construct an object in pre-allocated memory","Delete arrays","Make copies"],"correctAnswer":1},
  {"title":"Pointer arithmetic is only defined…","choices":["Across any memory","Within same array/object","Across different arrays","On void*"],"correctAnswer":1},
  {"title":"const_cast should be used…","choices":["To change const objects","Rarely, to interface legacy APIs when underlying object is non-const","Often to modify const","For concurrency"],"correctAnswer":1},
  {"title":"volatile is for…","choices":["Multithreading","Memory-mapped I/O / signals","Faster code","Exceptions"],"correctAnswer":1},
  {"title":"std::variant vs union:","choices":["variant is type-safe with active index","union is always safe","variant is C-only","union auto-tracks type"],"correctAnswer":0},
  {"title":"Exception safety strong guarantee means…","choices":["Program never throws","Operation either succeeds or has no effect","No resources leak","All exceptions are caught"],"correctAnswer":1},
  {"title":"noexcept on move helps containers because…","choices":["They can avoid reallocation","They prefer move in reallocation","They delete elements","They copy instead"],"correctAnswer":1},
  {"title":"Use std::optional when…","choices":["You need error details","You need presence/absence of a value","You need exceptions","You need shared ownership"],"correctAnswer":1},
  {"title":"Lambda move capture syntax:","choices":["[&x]","[x = std::move(x)]","[this]","[=]"],"correctAnswer":1},
  {"title":"Ranges are…","choices":["Eager pipelines","Lazy views and algorithms","Macros","Only for strings"],"correctAnswer":1},
  {"title":"Coroutines use…","choices":["co_return / co_yield / co_await","goto","yield in loops only","async only"],"correctAnswer":0},
  {"title":"Modules primarily help with…","choices":["Runtime speed only","Reducing header overhead/ODR and improving builds","Replacing templates","Eliminating linking"],"correctAnswer":1},
  {"title":"Data race in C++ is…","choices":["Well-defined","Implementation-defined","Undefined behavior","Always crashes"],"correctAnswer":2},
  {"title":"Acquire-Release pair establishes…","choices":["No order","Happens-before on shared data","Linker visibility","Exception neutrality"],"correctAnswer":1},
  {"title":"std::async returns…","choices":["std::thread","std::future","std::promise","std::optional"],"correctAnswer":1},
  {"title":"CAS loops risk…","choices":["ODR violations","ABA problems","Copy elision issues","constexpr overflow"],"correctAnswer":1},
  {"title":"thread_local gives…","choices":["Shared state","Per-thread storage","Faster heap","Global lock"],"correctAnswer":1},
  {"title":"ODR violation often appears as…","choices":["Multiple definition linker error","Missing header","Runtime exception","UBSAN warning only"],"correctAnswer":0},
  {"title":"Templates typically live in…","choices":[".cpp only","Headers (or explicit instantiation)","Shared libraries only","Linker scripts"],"correctAnswer":1}
  ,
  {"title":"Reference collapsing rule for T& & and T&& &:","choices":["Always T&&","& wins over && resulting in T&","&& wins over & resulting in T&&","Neither"],"correctAnswer":1},
  {"title":"Forwarding reference occurs when…","choices":["T&& in any context","T&& with template type deduction","const T&& in function","In class member function"],"correctAnswer":1},
  {"title":"std::move_if_noexcept prefers…","choices":["Move if noexcept, else copy","Copy always","Move always","Neither"],"correctAnswer":0},
  {"title":"Materialization conversion (C++17) means…","choices":["prvalues no longer create temporaries","prvalues materialize a temporary object as needed","lvalues turn into prvalues","xvalues become lvalues"],"correctAnswer":1},
  {"title":"Lifetime extension does NOT apply to…","choices":["Temporary bound to const T&","Temporary bound to const T&& local","Temporary used to initialize a data member via const ref","Temporary subobject bound to const ref"],"correctAnswer":1},
  {"title":"int&& parameter in non-template function binds to…","choices":["lvalues only","rvalues/xvalues","both","neither"],"correctAnswer":1},
  {"title":"Overload prefers rvalue overload when argument is…","choices":["lvalue","xvalue via std::move","glvalue only","prvalue blocked"],"correctAnswer":1},
  {"title":"Return by value of local in C++17 typically…","choices":["Creates a copy","Is elided (constructs directly)","Throws","Is undefined"],"correctAnswer":1},
  {"title":"Returning reference to local variable…","choices":["Ok with RVO","Always dangling (UB)","Ok with const","Becomes static"],"correctAnswer":1},
  {"title":"Capturing local by reference in async callback…","choices":["Safe always","Can dangle if callback outlives scope","Promotes to static","Forces copy"],"correctAnswer":1},
  {"title":"unique_ptr for arrays should use…","choices":["unique_ptr<T>","unique_ptr<T[]>","shared_ptr<T>","weak_ptr<T>"],"correctAnswer":1},
  {"title":"shared_ptr use_count is…","choices":["Thread-safe to read but not necessarily to modify","Always unsafe","Atomic modifications always","Lock-free always"],"correctAnswer":0},
  {"title":"enable_shared_from_this requires…","choices":["Construction via make_shared or existing shared_ptr","unique_ptr construction","weak_ptr first","new[]"],"correctAnswer":0},
  {"title":"Breaking shared_ptr cycles uses…","choices":["unique_ptr","weak_ptr","raw pointer","array new"],"correctAnswer":1},
  {"title":"Aliasing shared_ptr constructor shares…","choices":["Control block only","Ownership of both pointers","No control block","Atomic uniqueness"],"correctAnswer":0},
  {"title":"RAII with exceptions implies…","choices":["Manual try/finally","Destructors run during stack unwinding","Resources leak on throw","Skip destructors"],"correctAnswer":1},
  {"title":"Custom deleter for FILE* should…","choices":["call fclose","call delete","call free","do nothing"],"correctAnswer":0},
  {"title":"Function templates partial specialization:","choices":["Allowed","Not allowed; use overloading","Allowed only in C++20","Only with concepts"],"correctAnswer":1},
  {"title":"Detect idiom helps with…","choices":["Runtime RTTI","SFINAE-based trait detection","Link-time checks","ABI stability"],"correctAnswer":1},
  {"title":"requires-expression evaluates…","choices":["At runtime","At compile time for well-formedness","During linking","In debugger"],"correctAnswer":1},
  {"title":"Dependent name needs 'typename' when…","choices":["It names a type dependent on a template parameter","It names a value","It names a namespace","Never"],"correctAnswer":0},
  {"title":"Use 'template' disambiguator when…","choices":["Calling a dependent template member","Defining any template","Naming a type","Including headers"],"correctAnswer":0},
  {"title":"CRTP typical pattern is…","choices":["struct B: A<B> {}","struct B: virtual A {}","struct B final: A {}","struct B: A, C {}"],"correctAnswer":0},
  {"title":"constexpr if enables…","choices":["Runtime branching","Compile-time branching without SFINAE boilerplate","Link-time removal","Reflection"],"correctAnswer":1},
  {"title":"CTAD stands for…","choices":["Class Template Argument Deduction","Compile-Time Automatic Destruction","Cross TU ADL","Constexpr Type Alias Deduction"],"correctAnswer":0},
  {"title":"Deduction guides are used to…","choices":["Customize CTAD","Force runtime type","Replace templates","Create vtables"],"correctAnswer":0},
  {"title":"Vector<Base> push_back(Derived) by value causes…","choices":["No issue","Object slicing","Multiple vtables","Virtual inheritance"],"correctAnswer":1},
  {"title":"Deleting polymorphic base via base pointer requires…","choices":["Non-virtual dtor","Virtual destructor","final on base","override on base"],"correctAnswer":1},
  {"title":"override keyword ensures…","choices":["Method is inline","Method matches a virtual in base","Method is noexcept","Method is static"],"correctAnswer":1},
  {"title":"final on class means…","choices":["No more inheritance","No more copies","No exceptions","No templates"],"correctAnswer":0},
  {"title":"dynamic_cast requires…","choices":["Polymorphic base (at least one virtual)","Constexpr types","No RTTI","Modules"],"correctAnswer":0},
  {"title":"Virtual inheritance ensures…","choices":["Separate base subobjects","Single shared base subobject in diamond","Faster dispatch","No slicing"],"correctAnswer":1},
  {"title":"Placement new must be paired with…","choices":["delete","delete[]","explicit destructor call and deallocation by original allocator","free"],"correctAnswer":2},
  {"title":"Overloading operator new/delete allows…","choices":["Custom allocation strategies","Changing vtable","Inline virtuals","Compile-time memory"],"correctAnswer":0},
  {"title":"Strict aliasing rule means…","choices":["Any types may alias","Only certain related types may alias","No pointers may alias","Volatile disables aliasing"],"correctAnswer":1},
  {"title":"reinterpret_cast risks…","choices":["Type-safe conversion","Undefined behavior if aliasing/alignment violated","Compile-time error only","Automatic fixups"],"correctAnswer":1},
  {"title":"Bit-fields pitfalls include…","choices":["Portable layout","Implementation-defined packing and endianness concerns","Guaranteed atomicity","No padding"],"correctAnswer":1},
  {"title":"alignas is used to…","choices":["Query alignment","Specify minimum alignment","Remove padding","Force cache locality"],"correctAnswer":1},
  {"title":"union active member rule:","choices":["All members active","Only one active at a time; reading inactive member UB unless special cases","Safe to read any","Variant same behavior"],"correctAnswer":1},
  {"title":"std::launder is used when…","choices":["laundering strings","Reusing storage for new object placement to access new object reliably","deleting arrays","aligning"],"correctAnswer":1},
  {"title":"Exception neutrality implies…","choices":["Catching everything","Letting exceptions propagate and maintaining guarantees","Ignoring exceptions","std::terminate"],"correctAnswer":1},
  {"title":"noexcept operator (noexcept(expr)) returns…","choices":["Type","bool at compile time","runtime bool","void"],"correctAnswer":1},
  {"title":"throw() specification in C++11+ is…","choices":["Synonym for noexcept(true)","Deprecated/removed in favor of noexcept","No change","Runtime only"],"correctAnswer":1},
  {"title":"Use copy-and-swap to achieve…","choices":["Basic guarantee","Strong exception guarantee in assignment","Noexcept everywhere","Link-time optimization"],"correctAnswer":1},
  {"title":"std::expected (or similar) provides…","choices":["Exceptions","Value-or-error transport","Threading","Reflection"],"correctAnswer":1},
  {"title":"Lambda default capture [=] means…","choices":["Capture all by reference","Capture used names by value","Capture this by reference only","No captures"],"correctAnswer":1},
  {"title":"mutable lambda allows…","choices":["Captures to change in const operator()","Changing capture copies inside lambda body","Changing external variables","No effect"],"correctAnswer":1},
  {"title":"Generic lambda parameter type is…","choices":["auto","template<typename T>","void*","decltype(auto) only"],"correctAnswer":0},
  {"title":"Ranges views are…","choices":["Eager sequences","Lazy pipelines over underlying ranges","Always owning","Only for vectors"],"correctAnswer":1},
  {"title":"Dangling in ranges can occur when…","choices":["Using views over temporaries","Owning containers","Using std::array","Using std::string"],"correctAnswer":0},
  {"title":"Coroutine keywords are…","choices":["co_return/co_yield/co_await","yield/await","async/await only","co_try"],"correctAnswer":0},
  {"title":"Coroutine promise type…","choices":["Determines return/behavior of coroutine","Is always std::promise","Is ignored","Creates threads"],"correctAnswer":0},
  {"title":"Modules 'export' keyword…","choices":["Exports declarations from a module interface","Marks symbol inline","Forces dynamic linking","Disables ADL"],"correctAnswer":0},
  {"title":"Header units in modules…","choices":["Are standard headers as modules","Replace templates","Disable macros","Remove ABI issues"],"correctAnswer":0},
  {"title":"Happens-before ensures…","choices":["Deterministic scheduling","Proper visibility/ordering between threads","Faster code","No deadlocks"],"correctAnswer":1},
  {"title":"Data race occurs when…","choices":["Independent reads","Two conflicting accesses without synchronization, at least one write","Only writes","Only atomics"],"correctAnswer":1},
  {"title":"Release sequence starts at…","choices":["Any load","A release store followed by RMWs on same object","A fence","Mutex unlock"],"correctAnswer":1},
  {"title":"atomic_flag is…","choices":["Non-atomic","Simplest atomic type for spin locks","Deprecated","Only for 128-bit"],"correctAnswer":1},
  {"title":"False sharing is…","choices":["Threads sharing pointers","Multiple threads modifying different data on the same cache line causing slowdown","Compiler bug","Alignment requirement"],"correctAnswer":1},
  {"title":"condition_variable wait must…","choices":["Not check predicate","Always be in a loop checking predicate","Use busy wait","Throw on spurious wake"],"correctAnswer":1},
  {"title":"std::async launch policy may…","choices":["Always spawn thread","Defer until get() if deferred policy","Always be sequential","Never block"],"correctAnswer":1},
  {"title":"future::get()…","choices":["Never blocks","Blocks until ready and rethrows exceptions","Only returns default","Detaches thread"],"correctAnswer":1},
  {"title":"promise/future pair…","choices":["Incompatible","Channel for communicating results/exceptions","Locks a mutex","Replaces atomics"],"correctAnswer":1},
  {"title":"unique_lock vs lock_guard:","choices":["unique_lock is movable and can lock/defer; lock_guard is simple RAII","lock_guard is movable","unique_lock cannot be deferred","They are identical"],"correctAnswer":0},
  {"title":"ODR violation typical cause:","choices":["Multiple definitions across TUs","Missing include guards","Using inline","Using constexpr"],"correctAnswer":0},
  {"title":"Inline variable (C++17) helps…","choices":["Create multiple definitions","Provide a single definition across TUs","Disable templates","Remove vtables"],"correctAnswer":1},
  {"title":"static in headers causes…","choices":["One shared instance","Separate instance per TU (may be desired)","Linker error always","No effect"],"correctAnswer":1},
  {"title":"extern \"C\" used to…","choices":["Disable optimization","Use C linkage (no name mangling)","Force inlining","Enable RTTI"],"correctAnswer":1},
  {"title":"#pragma once is…","choices":["Standard C++","Widely supported but not standard; include guards are portable","Deprecated","Module feature"],"correctAnswer":1},
  {"title":"Explicit instantiation is…","choices":["Runtime feature","Way to compile templates in .cpp","Module import","Header guard"],"correctAnswer":1},
  {"title":"pimpl idiom benefits…","choices":["Worse ABI","Stable ABI and faster builds","No encapsulation","Header bloat"],"correctAnswer":1},
  {"title":"Name mangling encodes…","choices":["Only names","Function signatures for overloading","Visibility","Alignment"],"correctAnswer":1},
  {"title":"ADL can cause…","choices":["Better lookup of relevant functions","Unexpected overload picks if not constrained","No effect","Linker errors"],"correctAnswer":1},
  {"title":"Hidden friend operators help…","choices":["Avoid templates","Participate in ADL nicely","Break overloads","Remove constraints"],"correctAnswer":1},
  {"title":"std::move on const object…","choices":["Moves it","Produces const rvalue; typically triggers copy","Throws","Deletes"],"correctAnswer":1},
  {"title":"Self-move assignment should…","choices":["Be UB","Handle gracefully or guard","Always throw","Delete object"],"correctAnswer":1},
  {"title":"vector reallocation prefers…","choices":["Copy if move may throw","Move if move is noexcept","Always copy","Always move"],"correctAnswer":1},
  {"title":"std::string SBO means…","choices":["Static buffer optimization","Small buffer optimization in some implementations","Safe binary optimization","Spec-backed optimization"],"correctAnswer":1},
  {"title":"std::span is…","choices":["Owning","Non-owning view; beware dangling","Always dynamic","Atomic"],"correctAnswer":1},
  {"title":"std::string_view is…","choices":["Owning","Non-owning; lifetime must exceed view","Copy-on-write","Atomic"],"correctAnswer":1},
  {"title":"Over-aligned allocation needs…","choices":["alignas only","Aligned new/delete or custom allocators","volatile","reinterpret_cast"],"correctAnswer":1},
  {"title":"dynamic_cast across diamonds requires…","choices":["Virtual inheritance to have single base","Multiple vtables","Modules","No RTTI"],"correctAnswer":0},
  {"title":"virtual base initialization order…","choices":["Depends on derived order","Done by most-derived constructor","By base only","Undefined"],"correctAnswer":1},
  {"title":"noexcept(false) on move means…","choices":["Same as noexcept(true)","Move may throw; containers may copy instead","Disables copy","Forces RVO"],"correctAnswer":1},
  {"title":"std::hash specialization ODR rule:","choices":["Multiple differing specializations allowed","Only one per program (ODR) in global namespace","None","Runtime-checked"],"correctAnswer":1},
  {"title":"Template member 'template' keyword used when…","choices":["Calling a dependent member template","Declaring any template","Using concepts","Defining macros"],"correctAnswer":0},
  {"title":"no_unique_address attribute…","choices":["Prevents EBO","Enables EBO-like space elision for members","Creates alignment faults","Removes padding"],"correctAnswer":1},
  {"title":"atomic<T*> fetch_add increments by…","choices":["Bytes","sizeof(T)","Words","Undefined"],"correctAnswer":1},
  {"title":"memory_order_relaxed guarantees…","choices":["Ordering","Atomicity only","Visibility","Seq_cst"],"correctAnswer":1},
  {"title":"memory_order_seq_cst provides…","choices":["Per-variable order only","Single total order of seq_cst ops","No ordering","Stronger type safety"],"correctAnswer":1},
  {"title":"release fence ensures…","choices":["Nothing","Prior writes become visible before subsequent releases","All future ops reorder","Deadlocks"],"correctAnswer":1},
  {"title":"acquire fence ensures…","choices":["Subsequent reads see prior writes synchronized-with","Nothing","Only atomics","Faster code"],"correctAnswer":1},
  {"title":"hazard pointers help…","choices":["Lock-free memory reclamation","ABI stability","RVO","Modules"],"correctAnswer":0},
  {"title":"std::atomic is…","choices":["Always lock-free","May be lock-free; check is_lock_free()","Never lock-free","Seq_cst only"],"correctAnswer":1},
  {"title":"packaged_task provides…","choices":["Thread creation","A callable + future mechanism","Memory fences","Atomics"],"correctAnswer":1},
  {"title":"std::scoped_lock can…","choices":["Deadlock","Lock multiple mutexes without deadlock (try-lock internally)","Only one mutex","Defer locks"],"correctAnswer":1},
  {"title":"inline function ODR…","choices":["Allows multiple identical definitions across TUs","Forbids all duplicates","Runtime check","Linker merges randomly"],"correctAnswer":0},
  {"title":"header-only libraries work because…","choices":["Templates need no definitions","Templates are defined in headers so each TU instantiates as needed","Linker magic","Modules only"],"correctAnswer":1},
  {"title":"ADL suppression technique:","choices":["Using namespace std;","Wrap in detail namespace and call via qualified name","Inline namespaces","extern C"],"correctAnswer":1},
  {"title":"std::vector<bool> peculiarity:","choices":["Stores bool as actual bool","Bit-packed proxy type with references not real bool&","Uses atomics","Deprecated"],"correctAnswer":1},
  {"title":"emplace vs insert:","choices":["Always identical","emplace constructs in place; insert copies/moves existing object","insert faster","emplace slower"],"correctAnswer":1},
  {"title":"strong typedef pattern in C++20:","choices":["typedef only","using + wrapper struct + explicit","macros only","friend injection"],"correctAnswer":1},
  {"title":"std::byte intended for…","choices":["Text","Raw memory byte-wise operations","Networking only","Atomic ops only"],"correctAnswer":1},
  {"title":"std::any stores…","choices":["Only strings","Type-erased value with RTTI","Only numbers","References only"],"correctAnswer":1},
  {"title":"std::function overhead:","choices":["Zero-cost always","Type erasure can heap-allocate; SBO sometimes","Always inline","Never allocates"],"correctAnswer":1},
  {"title":"std::visit requires…","choices":["Only unions","Overloads or visitor callable for all alternatives","Dynamic_cast","Modules"],"correctAnswer":1},
  {"title":"Monostate pattern with variant:","choices":["Impossible","Use std::monostate as first alternative","Use nullptr","Use optional"],"correctAnswer":1},
  {"title":"optional vs variant for tristate:","choices":["optional always","variant with monostate or enum is clearer","Neither","Both identical"],"correctAnswer":1},
  {"title":"std::exchange is useful for…","choices":["Copying","Move-then-assign idioms and resetting values","Locking","ADL"],"correctAnswer":1},
  {"title":"Equality spaceship operator (C++20)…","choices":["Replaces all comparisons","Synthesizes comparisons in many cases and affects overloads","No effect","Removes equals"],"correctAnswer":1},
  {"title":"Three-way comparison category type depends on…","choices":["Return type only","Member-wise categories (strong/weak/partial) of comparisons","Linker","RTTI"],"correctAnswer":1},
  {"title":"Designated initializers in C++20…","choices":["Allow any order with non-aggregates","Work for aggregates only (with constraints)","Replace constructors","Are modules only"],"correctAnswer":1},
  {"title":"Aggregate requires…","choices":["No user-provided ctors or private/protected non-static data members","Virtual functions","Templates","ABI flags"],"correctAnswer":0},
  {"title":"std::array size is…","choices":["Dynamic","Compile-time fixed","Runtime only","Zero"],"correctAnswer":1},
  {"title":"erase-remove idiom…","choices":["Removes elements directly","Uses remove to partition and container erase to shrink","No longer needed","Undefined"],"correctAnswer":1},
  {"title":"transient string_view bug arises when…","choices":["Viewing temp string return and storing view","Using std::string","Using vector","Using span"],"correctAnswer":0},
  {"title":"constexpr constructor must…","choices":["Always run at runtime","Satisfy constexpr rules and not throw (pre C++20)","Allocate memory","Use virtual"],"correctAnswer":1},
  {"title":"noexcept + strong guarantee interplay:","choices":["Unrelated","noexcept often on move/swap enables strong guarantee implementations","Forbids throws everywhere","Only for copy"],"correctAnswer":1},
  {"title":"constexpr virtual functions…","choices":["Common","Limited; virtual dispatch is runtime","Always inline","Modules only"],"correctAnswer":1},
  {"title":"[[nodiscard]] attribute suggests…","choices":["Return value may be ignored","Return value should be used; ignoring may warn","For constructors","For destructors"],"correctAnswer":1},
  {"title":"std::optional emplace…","choices":["Destroys contained then constructs in place","Copies value","Always allocates","Throws on nullopt"],"correctAnswer":0},
  {"title":"vector capacity growth…","choices":["Fixed","Typically geometric growth (implementation-defined)","Linear only","UB"],"correctAnswer":1},
  {"title":"emplace_back with args…","choices":["Constructs element in place","Always copies then moves","Only works for strings","Deprecated"],"correctAnswer":0},
  {"title":"std::array vs vector key diff:","choices":["array is dynamic","array size fixed at compile time","vector is fixed","array allocates on heap"],"correctAnswer":1},
  {"title":"Move constructor of std::vector complexity:","choices":["Linear always","Constant (pointer steal) typically","Quadratic","Undefined"],"correctAnswer":1},
  {"title":"std::deque iterator invalidation:","choices":["Never invalidates","Insert/erase at ends may not invalidate all iterators; middle operations can","Always invalidates","Same as vector"],"correctAnswer":1},
  {"title":"Equality operator default generation (C++20):","choices":["Always generated","Generated when =default and members comparable","Never","Only for aggregates"],"correctAnswer":1},
  {"title":"delete[] must match…","choices":["new","new[]","malloc","free"],"correctAnswer":1},
  {"title":"std::unique_ptr custom deleter type affects…","choices":["Runtime only","Type of unique_ptr; may change size and move semantics","Nothing","Only ABI"],"correctAnswer":1},
  {"title":"std::weak_ptr::lock returns…","choices":["raw pointer","shared_ptr (empty if expired)","bool","unique_ptr"],"correctAnswer":1},
  {"title":"shared_ptr atomic vs non-atomic counts:","choices":["Always atomic","Control block uses atomic for shared count; weak count also atomic; internal details impl-defined","Never atomic","Only weak is atomic"],"correctAnswer":1},
  {"title":"Prefer make_shared because…","choices":["Slower","Single allocation and exception safety","Removes cycles","For arrays"],"correctAnswer":1},
  {"title":"std::enable_shared_from_this misuse:","choices":["Calling shared_from_this() before owned by shared_ptr leads to bad_weak_ptr","Always safe","Works with unique_ptr","Works with raw new"],"correctAnswer":0},
  {"title":"Concepts constrain…","choices":["Runtime values","Templates at compile time","Linker",
  "Exceptions"],"correctAnswer":1},
  {"title":"template<typename T> using alias … specialization:","choices":["Aliases can be partially specialized (alias templates)","Aliases cannot be specialized","Only full specialization","Never allowed"],"correctAnswer":0},
  {"title":"Dependent base name lookup requires…","choices":["this-> or using-declaration","Nothing","virtual","override"],"correctAnswer":0},
  {"title":"virtual function call in ctor/dtor dispatches to…","choices":["Most-derived override","Current class (non-virtual-like) — base version","Derived always","Final"],"correctAnswer":1},
  {"title":"std::aligned_storage status:","choices":["Modern and recommended","Deprecated in favor of aligned allocation / std::byte + new","For atomics only","Modules only"],"correctAnswer":1},
  {"title":"reinterpret_cast to different size pointer…","choices":["Safe","UB if misaligned/incorrect; size mismatch unsafe","Always works","For modules"],"correctAnswer":1},
  {"title":"std::atomic<T> requirements:","choices":["T must be trivially copyable","Any type","Only integers","Only pointers"],"correctAnswer":0},
  {"title":"Acquire on load ensures…","choices":["Subsequent reads/writes not reordered before it","Nothing","Previous writes flushed","Seq_cst"],"correctAnswer":0},
  {"title":"Release on store ensures…","choices":["Prior reads/writes not moved after it","Nothing","Loads reordered","Seq_cst only"],"correctAnswer":0},
  {"title":"Spin lock with atomic_flag should…","choices":["Use test_and_set/clear","Use mutex","Use vector","Use free"],"correctAnswer":0},
  {"title":"std::condition_variable requires…","choices":["std::mutex and unique_lock","shared_mutex","spinlock","none"],"correctAnswer":0},
  {"title":"shared_mutex allows…","choices":["Multiple readers or one writer","Only one thread","Only readers","Only writers"],"correctAnswer":0},
  {"title":"inline namespace usage:","choices":["ADL only","Versioning to manage ABI while keeping name lookup simple","Modules only","No use"],"correctAnswer":1},
  {"title":"Header cycles avoided by…","choices":["Include guards and forward declarations","Duplicating code","Macros only","Modules always"],"correctAnswer":0},
  {"title":"Forward declaration allows…","choices":["Using size/layout","Declaring pointers/references to incomplete types","Accessing members","Virtual calls"],"correctAnswer":1},
  {"title":"ODR-use of a variable means…","choices":["Used in a way requiring its definition","Only declared","Never defined","Inline only"],"correctAnswer":0},
  {"title":"ABI break happens when…","choices":["Changing private member order in exported class across releases","Changing local var name","Adding comment","Whitespace change"],"correctAnswer":0},
  {"title":"extern template reduces…","choices":["Runtime","Code bloat and compile time by centralizing instantiation","Link time","Exceptions"],"correctAnswer":1},
  {"title":"Module partitions allow…","choices":["Splitting interfaces/implementations within a module","Multiple definitions","No imports","ODR violations"],"correctAnswer":0},
  {"title":"Co_await on ready future…","choices":["Always blocks","May suspend or return immediately depending on awaiter","Throws","Undefined"],"correctAnswer":1},
  {"title":"std::jthread advantage over std::thread:","choices":["No difference","Automatic join on destruction and stop_token support","Moves faster","Uses coroutines"],"correctAnswer":1}
]
