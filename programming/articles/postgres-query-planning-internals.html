<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>PostgreSQL Query Planning Internals</title>
  <style>:root{--primary:#1e88e5;--bg:#f7f9fc;--text:#1a1a1a;--muted:#6b7280}*{box-sizing:border-box}body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);background:var(--bg)}header{background:#fff;border-bottom:1px solid #e5e7eb;position:sticky;top:0;z-index:10}.container{max-width:980px;margin:0 auto;padding:16px}.title{margin:6px 0 2px;font-size:24px;font-weight:800}.subtitle{margin:0 0 12px;color:var(--muted)}.toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}button{background:var(--primary);color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:600}button.secondary{background:#eef2ff;color:#1f2937}button.ghost{background:transparent;color:#1f2937;border:1px solid #e5e7eb}main.container article{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:18px}h2{margin-top:20px}pre{background:#0b1020;color:#e5e7eb;padding:12px;border-radius:10px;overflow:auto;border:1px solid #111827}code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0b1020;color:#e5e7eb;padding:1px 4px;border-radius:4px}.tok-kw{color:#93c5fd}.tok-str{color:#a7f3d0}.tok-com{color:#9ca3af;font-style:italic}.tok-num{color:#fcd34d}.tok-builtin{color:#fca5a5}.note{background:#fefce8;border:1px solid #fde68a;color:#713f12;padding:12px;border-radius:10px}.toc a{color:#2563eb;text-decoration:none}</style>
  <script>function E(s){return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;')}function H(src){if(!src)return'';const K=[];const keep=h=>(K.push(h),`@@H${K.length-1}@@`);src=src.replace(/'{3}[\s\S]*?'{3}|"{3}[\s\S]*?"{3}/g,m=>keep(`<span class='tok-str'>${E(m)}</span>`));src=src.replace(/'(?:\\.|[^'\\])*'|"(?:\\.|[^"\\])*"/g,m=>keep(`<span class='tok-str'>${E(m)}</span>`));src=src.replace(/#.*/g,m=>keep(`<span class='tok-com'>${E(m)}</span>`));let html=E(src);const KW=['def','return','if','elif','else','for','while','in','not','and','or','class','import','from','as','try','except','finally','with','lambda','True','False','None','pass','break','continue','yield','global','nonlocal','assert','raise','del','is'];html=html.replace(new RegExp(`\\b(${KW.join('|')})\\b`,'g'),"<span class='tok-kw'>$1</span>");const BI=['len','range','print','dict','list','set','tuple','int','str','float','bool','sum','min','max','sorted','enumerate','zip','map','filter'];html=html.replace(new RegExp(`\\b(${BI.join('|')})\\b`,'g'),"<span class='tok-builtin'>$1</span>");html=html.replace(/\b0x[0-9a-fA-F_]+\b|\b\d+(?:\.\d+)?\b/g,"<span class='tok-num'>$&</span>");return html.replace(/@@H(\d+)@@/g,(m,i)=>K[Number(i)])}function apply(){document.querySelectorAll('pre code.language-python').forEach(el=>el.innerHTML=H(el.textContent||''))}window.addEventListener('DOMContentLoaded',apply)</script>
</head><body>
  <header><div class="container">
    <div class="title">PostgreSQL Query Planning Internals</div>
    <div class="subtitle">Cost model, join strategies, parallelism, stats, and EXPLAIN</div>
    <div class="toolbar">
      <button class="secondary" onclick="window.location.href='../index.html?id=postgres-query-planning-internals'">Start Quiz</button>
      <button class="ghost" onclick="window.location.href='../index.html'">Back to Quizzes</button>
    </div>
  </div></header>
  <main class="container"><article>
    <div class="toc"><strong>Contents</strong>
      <ul>
        <li><a href="#cost">1. Cost Model</a></li>
        <li><a href="#join">2. Join Strategies</a></li>
        <li><a href="#stats">3. Extended Stats</a></li>
        <li><a href="#explain">4. EXPLAIN</a></li>
      </ul>
    </div>
    <h2 id="cost">1. Cost Model</h2>
    <p><code>seq_page_cost</code>, <code>random_page_cost</code>, CPU costs guide plan selection; parallelism triggers based on cost thresholds.</p>
    <h2 id="join">2. Join Strategies</h2>
    <p>Nested Loop for selective lookups with indexes; Hash Join for large equi-joins; Merge Join for pre-sorted inputs.</p>
    <h2 id="stats">3. Extended Statistics</h2>
    <p>MCV, ndistinct, and functional dependencies improve cardinality estimates for correlated predicates.</p>
    <h2 id="explain">4. EXPLAIN</h2>
    <p>Use EXPLAIN to see the plannerâ€™s choices and, with ANALYZE, actual runtime behavior. Below are practical examples and the most useful switches.</p>

    <h3>EXPLAIN Options & Formats</h3>
    <ul>
      <li><strong>EXPLAIN</strong>: shows the estimated plan without executing the query.</li>
      <li><strong>ANALYZE</strong>: executes the query and shows actual runtime and row counts; required for <code>BUFFERS</code>.</li>
      <li><strong>BUFFERS</strong>: reports shared/local/temp hits and reads; only with <code>ANALYZE</code>.</li>
      <li><strong>TIMING OFF</strong>: still executes and counts rows but skips per-node timing overhead.</li>
      <li><strong>VERBOSE</strong>: shows additional details like output (target) columns and internal names.</li>
      <li><strong>COSTS OFF</strong>: hides estimated startup/total cost, rows, and width fields.</li>
      <li><strong>SUMMARY</strong>: includes planning and execution time totals.</li>
      <li><strong>SETTINGS</strong>: lists GUC settings that affected planning/execution.</li>
      <li><strong>FORMAT JSON</strong>: returns a JSON array with one object containing the Plan tree.</li>
    </ul>

    <h3>Basic text plan (estimates only)</h3>
    <pre><code>EXPLAIN
SELECT *
FROM orders
WHERE customer_id = 42 AND order_date &gt;= DATE '2025-01-01';

                                   QUERY PLAN
----------------------------------------------------------------------------------
 Index Scan using orders_customer_id_date_idx on orders
   (cost=0.43..85.12 rows=123 width=64)
   Index Cond: ((customer_id = 42) AND (order_date &gt;= '2025-01-01'::date))
(2 rows)
    </code></pre>

    <h3>With actuals and I/O stats</h3>
    <pre><code>EXPLAIN (ANALYZE, BUFFERS)
SELECT *
FROM orders
WHERE customer_id = 42 AND order_date &gt;= DATE '2025-01-01';

 Index Scan using orders_customer_id_date_idx on orders
   (cost=0.43..85.12 rows=123 width=64)
   (actual rows=120 loops=1)
   Index Cond: ((customer_id = 42) AND (order_date &gt;= '2025-01-01'::date))
   Buffers: shared hit=502 read=10
 Planning Time: 0.312 ms
 Execution Time: 2.145 ms
    </code></pre>

    <h3>ANALYZE with TIMING OFF</h3>
    <pre><code>EXPLAIN (ANALYZE, BUFFERS, TIMING OFF)
SELECT * FROM orders WHERE customer_id = 42 AND order_date &gt;= DATE '2025-01-01';

 Index Scan using orders_customer_id_date_idx on orders
   (cost=0.43..85.12 rows=123 width=64)
   (actual rows=120 loops=1)  -- per-node timings suppressed
   Index Cond: ((customer_id = 42) AND (order_date &gt;= '2025-01-01'::date))
   Buffers: shared hit=502 read=10
 Planning Time: 0.290 ms
 Execution Time: 2.021 ms
    </code></pre>

    <h3>VERBOSE shows output columns</h3>
    <pre><code>EXPLAIN (VERBOSE)
SELECT id, order_date FROM orders
WHERE customer_id = 42 ORDER BY order_date DESC LIMIT 5;

 Limit  (cost=0.43..12.34 rows=5 width=16)
   Output: orders.id, orders.order_date
   -&gt;  Index Only Scan using orders_customer_date_desc_idx on public.orders
         (cost=0.43..123.45 rows=1000 width=16)
         Output: orders.id, orders.order_date
         Index Cond: (orders.customer_id = 42)
    </code></pre>

    <h3>COSTS OFF trims estimate fields</h3>
    <pre><code>EXPLAIN (COSTS OFF)
SELECT * FROM orders WHERE customer_id = 42;

 Index Scan using orders_customer_id_idx on orders
   Index Cond: (customer_id = 42)
    </code></pre>

    <h3>SUMMARY and SETTINGS</h3>
    <pre><code>SET enable_seqscan = off;  -- force index usage for demo
EXPLAIN (ANALYZE, SUMMARY, SETTINGS)
SELECT * FROM orders WHERE customer_id = 42;

 Index Scan using orders_customer_id_idx on orders
   (actual rows=120 loops=1)
   Index Cond: (customer_id = 42)
 Settings: enable_seqscan = 'off'
 Planning Time: 0.250 ms
 Execution Time: 1.800 ms
    </code></pre>

    <h3>FORMAT JSON (machine-readable)</h3>
    <pre><code>EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
SELECT * FROM orders WHERE customer_id = 42 AND order_date &gt;= DATE '2025-01-01';

[
  {
    "Plan": {
      "Node Type": "Index Scan",
      "Relation Name": "orders",
      "Alias": "orders",
      "Index Name": "orders_customer_id_date_idx",
      "Startup Cost": 0.43,
      "Total Cost": 85.12,
      "Plan Rows": 123,
      "Plan Width": 64,
      "Actual Rows": 120,
      "Actual Loops": 1,
      "Index Cond": "((customer_id = 42) AND (order_date >= '2025-01-01'::date))",
      "Buffers": { "Shared Hit": 502, "Shared Read": 10 }
    },
    "Planning Time": 0.312,
    "Execution Time": 2.145,
    "Settings": { "enable_seqscan": "off" }
  }
]
    </code></pre>

    <div class="note">Tip: Use <code>ANALYZE</code> for truth, <code>BUFFERS</code> for I/O, <code>TIMING OFF</code> to lower overhead, <code>VERBOSE</code> to inspect outputs, <code>JSON</code> for tooling, and <code>SETTINGS</code> to capture non-default GUCs that affected the plan.</div>
  </article></main>
</body></html>
