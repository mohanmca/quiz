<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rabin–Karp Rolling Hash Fundamentals</title>
  <style>
    :root { --primary:#1e88e5; --bg:#f7f9fc; --text:#1a1a1a; --muted:#6b7280; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:var(--text); background:var(--bg); }
    header { background:#fff; border-bottom:1px solid #e5e7eb; position:sticky; top:0; z-index:10; }
    .container { max-width: 980px; margin: 0 auto; padding: 16px; }
    .title { margin: 6px 0 2px; font-size: 24px; font-weight: 800; }
    .subtitle { margin: 0 0 12px; color: var(--muted); }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap: wrap; margin-top: 8px; }
    button { background: var(--primary); color: #fff; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    button.secondary { background:#eef2ff; color:#1f2937; }
    button.ghost { background:transparent; color:#1f2937; border:1px solid #e5e7eb; }
    main.container article { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:18px; }
    h2 { margin-top: 20px; }
    h3 { margin-top: 16px; }
    p { line-height: 1.6; }
    ul { margin-top: 8px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1020; color:#e5e7eb; padding: 1px 4px; border-radius:4px; }
    pre { background:#0b1020; color:#e5e7eb; padding:12px; border-radius:10px; overflow-x:auto; border:1px solid #111827; }
    pre code { display:block; background:transparent; padding:0; }
    table { width:100%; border-collapse: collapse; margin: 12px 0; }
    th, td { border:1px solid #e5e7eb; padding:10px; text-align:left; }
    th { background:#f9fafb; font-weight:700; }
    tbody tr:nth-child(even) { background:#fafafa; }
    .diagram { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background:#f8fafc; border:1px solid #e5e7eb; color:#0f172a; padding:12px; border-radius:10px; overflow-x:auto; }
    .diagram .muted { color:#64748b; }
    .viz { background:#f8fafc; border:1px solid #e5e7eb; border-radius:10px; padding:8px; }
    .viz svg { max-width:100%; height:auto; display:block; }
    .viz text { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px; fill:#0f172a; }
    .viz .idx { fill:#64748b; font-size:11px; }
    .viz .box { fill:#e2e8f0; stroke:#94a3b8; }
    .viz .hilite { fill:#bfdbfe; stroke:#3b82f6; }
    .viz .arrow { stroke:#0f172a; stroke-width:1.2; marker-end:url(#arrowhead); }
    /* Lightweight syntax highlighting */
    .tok-kw { color:#93c5fd; }
    .tok-str { color:#a7f3d0; }
    .tok-com { color:#9ca3af; font-style:italic; }
    .tok-num { color:#fcd34d; }
    .tok-builtin { color:#fca5a5; }
    .tip { background:#ecfdf5; border:1px solid #10b98133; color:#065f46; padding:12px; border-radius:10px; }
    .note { background:#fefce8; border:1px solid #fde68a; color:#713f12; padding:12px; border-radius:10px; }
    .muted { color: var(--muted); }
    .toc a { color:#2563eb; text-decoration:none; }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <div class="title">Rabin–Karp Rolling Hash Fundamentals</div>
      <div class="subtitle">Step-by-step guide with Python code, collisions, modular arithmetic, and practical patterns</div>
      <div class="toolbar">
        <button class="secondary" onclick="window.location.href='../index.html?id=rabin-karp-rolling-hash'">Start Quiz</button>
        <button class="ghost" onclick="window.location.href='../index.html'">Back to Quizzes</button>
      </div>
    </div>
  </header>
  <main class="container">
    <article>
      <div class="toc">
        <strong>Contents:</strong>
        <ul>
          <li><a href="#intro">1. Intuition</a></li>
          <li><a href="#naive">2. Naïve vs. Rabin–Karp</a></li>
          <li><a href="#polyhash">3. Polynomial Rolling Hash</a></li>
          <li><a href="#rolling">4. Rolling Update</a></li>
          <li><a href="#impl">5. A Minimal Python Implementation</a></li>
          <li><a href="#collisions">6. Collisions and Double Hashing</a></li>
          <li><a href="#multipattern">7. Multiple Pattern Matching</a></li>
          <li><a href="#tips">8. Practical Tips and Pitfalls</a></li>
          <li><a href="#mod">9. Modulo Math Essentials</a></li>
          <li><a href="#modtricks">10. Mod Tricks for Interviews</a></li>
          <li><a href="#usage">11. Where Rabin–Karp Shines</a></li>
          <li><a href="#kmp">12. KMP: Quick Primer</a></li>
          <li><a href="#compare">13. RK vs KMP: Comparison</a></li>
          <li><a href="#practice">14. Practice Exercises</a></li>
        </ul>
      </div>

      <h2 id="intro">1. Intuition</h2>
      <p>
        Rabin–Karp accelerates substring search by comparing <em>hashes</em> of the pattern and each
        window of the text before performing an exact comparison. If the hashes don’t match, we skip
        the character-by-character check. If they match, we verify to defend against collisions.
      </p>

      <h2 id="naive">2. Naïve vs. Rabin–Karp</h2>
      <ul>
        <li><strong>Naïve:</strong> Compare each window character-by-character → worst-case O(nm).</li>
        <li><strong>Rabin–Karp:</strong> Maintain a rolling hash for each window. Average O(n); worst-case O(nm) when many collisions.</li>
      </ul>

      <h2 id="polyhash">3. Polynomial Rolling Hash</h2>
      <p>
        For string <code>s[0..m-1]</code> we commonly use a polynomial hash:
      </p>
      <pre><code class="language-python"># H = (s[0]*base^0 + s[1]*base^1 + ... + s[m-1]*base^(m-1)) % M
# base: weights positions; M: large prime to avoid overflow and spread values
</code></pre>
      <p>
        Choose <code>base</code> according to alphabet: 31 for lowercase letters, 256 for bytes. Choose a large prime <code>M</code>
        like <code>1_000_000_007</code> or <code>1_000_000_009</code>. Map characters to small integers, e.g. <code>ord(c)</code> or <code>ord(c)-96</code> for 'a'..'z'.
      </p>
      <div class="tip">Precompute <code>pow_base[i] = base^i % M</code> so removing the outgoing character is O(1).</div>
      <h3 id="base">Choosing the Base b: How and Why</h3>
      <ul>
        <li><strong>Cover the alphabet:</strong> pick <code>b ≥ |Σ|</code> (alphabet size). Examples: <code>b=4</code> for DNA (A,C,G,T); <code>b=26..31</code> for lowercase; <code>b=256</code> for bytes.</li>
        <li><strong>Avoid degenerate bases:</strong> <code>b=1</code> eliminates positional weight so different strings collide easily. Use <code>b ≥ 2</code>.</li>
        <li><strong>Co-prime with M:</strong> ensure <code>gcd(b, M)=1</code> so inverses exist when needed and to avoid pathological cycles; with prime <code>M</code>, any <code>1 ≤ b &lt; M</code> works.</li>
        <li><strong>Distribution vs overflow:</strong> larger <code>b</code> tends to mix positions more strongly but don’t let <code>b</code> approach <code>M</code>. In practice, <code>b</code> in the few hundreds to thousands with <code>M≈1e9+7</code> is fine.</li>
        <li><strong>Randomize for robustness:</strong> choose <code>b</code> uniformly from a safe range at runtime to defend against adversarial inputs that cause collisions.</li>
        <li><strong>Double hashing:</strong> use two independent pairs <code>(b₁,M₁)</code>, <code>(b₂,M₂)</code> with unrelated bases and large distinct primes.</li>
        <li><strong>Normalization/encoding:</strong> normalize case/Unicode if needed; map symbols to dense integers starting from 0 for compact arithmetic.</li>
      </ul>

      <h2 id="rolling">4. Rolling Update</h2>
      <p>
        For window length <code>m</code>, when sliding right by one character (remove <code>s_out</code>, add <code>s_in</code>):
      </p>
      <pre><code class="language-python"># H' = (H - s_out * base^(m-1)) * base + s_in   (mod M)
# Handle negatives safely by adding M before taking % M again.
</code></pre>
      <pre><code class="language-python">def roll_hash_right(H, s_out, s_in, base, pow_m_1, M):
    # remove outgoing contribution
    H = (H - (s_out * pow_m_1) % M) % M
    # shift window and add incoming
    H = (H * base + s_in) % M
    return H
</code></pre>

      <h2 id="impl">5. A Minimal Python Implementation</h2>
      <p>We’ll build Rabin–Karp in three steps: hash helpers, initial window, sliding loop.</p>
      <pre><code class="language-python">def poly_hash(arr, base, M):
    """Compute polynomial hash for an integer array arr (e.g., ord values)."""
    H = 0
    for x in arr:
        H = (H * base + x) % M
    return H

def rabin_karp(text: str, pattern: str, base=256, M=1_000_000_007):
    n, m = len(text), len(pattern)
    if m == 0 or m > n:
        return []

    t = [ord(c) for c in text]
    p = [ord(c) for c in pattern]

    pow_m_1 = pow(base, m-1, M)
    H_pat = poly_hash(p, base, M)
    H_win = poly_hash(t[:m], base, M)

    ans = []
    if H_win == H_pat and text[:m] == pattern:
        ans.append(0)

    for i in range(m, n):
        H_win = (H_win - (t[i-m] * pow_m_1) % M) % M
        H_win = (H_win * base + t[i]) % M

        if H_win == H_pat:
            # verify to avoid collision
            start = i - m + 1
            if text[start:start+m] == pattern:
                ans.append(start)
    return ans

# Example
if __name__ == '__main__':
    print(rabin_karp('abracadabra', 'abra'))  # [0, 7]
</code></pre>

      <h3>Handling Collisions with Double Hashing</h3>
      <pre><code class="language-python">def rabin_karp_double(text, pattern,
                      base1=911382323, M1=972663749,
                      base2=972663749, M2=1_000_000_007):
    n, m = len(text), len(pattern)
    if m == 0 or m > n:
        return []

    t = [ord(c) for c in text]
    p = [ord(c) for c in pattern]

    pow1 = pow(base1, m-1, M1)
    pow2 = pow(base2, m-1, M2)

    def H(arr, base, M):
        h = 0;
        for x in arr:
            h = ((h * base) % M + x) % M        
        return h

    hp1 = H(p, base1, M1); hw1 = H(t[:m], base1, M1)
    hp2 = H(p, base2, M2); hw2 = H(t[:m], base2, M2)

    ans = []
    def ok(i):
        return text[i:i+m] == pattern

    if hw1 == hp1 and hw2 == hp2 and ok(0):
        ans.append(0)

    for i in range(m, n):
        # hash 1
        hw1 = (hw1 - (t[i-m] * pow1) % M1) % M1
        hw1 = (hw1 * base1 + t[i]) % M1
        # hash 2
        hw2 = (hw2 - (t[i-m] * pow2) % M2) % M2
        hw2 = (hw2 * base2 + t[i]) % M2

        if hw1 == hp1 and hw2 == hp2:
            start = i - m + 1
            if ok(start):
                ans.append(start)
    return ans
</code></pre>

      <h2 id="collisions">6. Collisions and Double Hashing</h2>
      <ul>
        <li>Collisions are possible. When hashes match, verify substring equality.</li>
        <li>Double hashing (two independent (base, M) pairs) drastically reduces collision probability.</li>
        <li>Always normalize negatives after subtraction with <code>(x % M + M) % M</code>.</li>
      </ul>
      <h3>When and Why to Use Double Hashing</h3>
      <ul>
        <li><strong>Adversarial or dense matches:</strong> If data may cause many collisions (e.g., repeated characters or crafted inputs), double hashing reduces false positives.</li>
        <li><strong>Many windows:</strong> For long texts with <code>N = n - m + 1</code> windows, even low per-window collision rates can add up; double hashing keeps total risk low.</li>
        <li><strong>Performance:</strong> It cuts down expensive verifications when pattern occurrences are rare.</li>
      </ul>
      <p>
        Collision model (idealized uniform hashes): per-window collision probability is about <code>~ 1/M</code>. Over <code>N</code> windows, the union bound gives at most <code>N/M</code> chance that any window collides. With two independent pairs <code>(base₁, M₁)</code> and <code>(base₂, M₂)</code>, the joint collision probability is about <code>1/(M₁·M₂)</code>, and over <code>N</code> windows at most <code>N/(M₁·M₂)</code>.
      </p>
      <div class="note">Choose large, independent primes for <code>M₁, M₂</code> (e.g., <code>1e9+7</code> and <code>1e9+9</code>) and unrelated bases. Verification remains necessary but will trigger far less often.</div>

      <h2 id="multipattern">7. Multiple Pattern Matching</h2>
      <p>
        Rabin–Karp shines when searching many patterns of the <em>same length</em> against one text.
        Compute the pattern hashes once and store them in a set. Slide over the text and check if a
        window hash is in the set; verify on match.
      </p>
      <pre><code class="language-python">def find_any(text, patterns, base=256, M=1_000_000_007):
    # patterns: list of strings, assumed same length m
    if not patterns:
        return []
    m = len(patterns[0])
    if any(len(p) != m for p in patterns):
        raise ValueError('All patterns must have the same length')

    t = [ord(c) for c in text]
    P = [[ord(c) for c in p] for p in patterns]

    def H(arr, base, M):
        h = 0;
        for x in arr:
            h = ((h * base) % M + x) % M        
        return h

    targets = { H(p, base, M): p for p in P }
    if len(text) < m:
        return []

    pow_m_1 = pow(base, m-1, M)
    h = H(t[:m], base, M)
    out = []
    if h in targets and text[:m] == ''.join(map(chr, targets[h])):
        out.append((0, text[:m]))

    for i in range(m, len(text)):
        h = (h - (t[i-m]*pow_m_1) % M) % M
        h = (h * base + t[i]) % M
        if h in targets:
            start = i - m + 1
            cand = text[start:start+m]
            if cand == ''.join(map(chr, targets[h])):
                out.append((start, cand))
    return out
</code></pre>

      <h2 id="tips">8. Practical Tips and Pitfalls</h2>
      <ul>
        <li><strong>Base selection:</strong> 31 for lowercase letters; 256 for bytes; any base ≥ alphabet size.</li>
        <li><strong>Modulus:</strong> large primes near <code>1e9+7</code>/<code>1e9+9</code> are common. Keep all operations under mod.</li>
        <li><strong>Precompute:</strong> <code>base^(m-1) % M</code> for fast outgoing char removal.</li>
        <li><strong>Negative values:</strong> add <code>M</code> before another <code>% M</code>.</li>
        <li><strong>Worst-case:</strong> O(nm) if many collisions; double-hash + verify to mitigate.</li>
        <li><strong>Unicode:</strong> Using <code>ord</code> works; consider normalization (NFC/NFD) if needed.</li>
      </ul>
      <h3 id="offbyone">Indexing and Off-by-One Pitfalls</h3>
      <ul>
        <li><strong>Window count:</strong> a text of length <code>n</code> has <code>n - m + 1</code> windows of length <code>m</code>.</li>
        <li><strong>Loop indexing:</strong> if <code>i</code> is the index of the newly added character (right end), the window start is <code>start = i - m + 1</code>.</li>
        <li><strong>Slice verification:</strong> compare <code>text[start:start+m]</code> to the pattern. Do not use <code>i-m</code> or <code>i+m</code> by mistake.</li>
        <li><strong>Rolling order:</strong> remove <code>text[i-m]</code>, then multiply by <code>base</code>, then add <code>text[i]</code>.</li>
        <li><strong>First window:</strong> initialize from <code>text[0:m]</code> before the loop; the loop typically runs <code>i = m .. n-1</code>.</li>
        <li><strong>Zero vs one-based:</strong> math derivations are often 1-based; code is 0-based. Translate <code>i-m+1</code> carefully.</li>
      </ul>
      <div class="diagram" aria-label="Forward slide window indexing diagram">
        Forward slide (rightward), m = 4
        
        Index:  0  1  2  3  4  5  6  7
        Text :  a  b  r  a  c  a  d  a
                 └────────┘
                 start=0, end=3, i=3  => start = i - m + 1 = 0
                    └────────┘
                    start=1, end=4, i=4  => start = 4 - 4 + 1 = 1
        
        Update at each i ≥ m:
          - outgoing index = i - m
          - incoming index = i
          - next start     = i - m + 1
      </div>
      <figure class="viz" aria-label="Forward slide window indexing SVG diagram">
        <svg viewBox="0 0 560 120" role="img">
          <defs>
            <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
              <path d="M0,0 L6,3 L0,6 Z" fill="#0f172a"></path>
            </marker>
          </defs>
          <!-- indices row -->
          <text class="idx" x="10" y="20">Index:</text>
          <!-- boxes 0..7 -->
          <g transform="translate(70,5)">
            <g>
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">0</text>
            </g>
            <g transform="translate(40,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">1</text>
            </g>
            <g transform="translate(80,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">2</text>
            </g>
            <g transform="translate(120,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">3</text>
            </g>
            <g transform="translate(160,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">4</text>
            </g>
            <g transform="translate(200,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">5</text>
            </g>
            <g transform="translate(240,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">6</text>
            </g>
            <g transform="translate(280,0)">
              <rect class="box" x="0" y="6" width="40" height="24"></rect>
              <text x="15" y="24">7</text>
            </g>
          </g>
          <!-- first window highlight [0..3] at i=3 -->
          <g transform="translate(70,40)">
            <rect class="hilite" x="0" y="0" width="160" height="24"></rect>
            <text x="0" y="44">start=0, end=3, i=3 ⇒ start = i - m + 1 = 0</text>
          </g>
          <!-- next window highlight [1..4] at i=4 -->
          <g transform="translate(110,75)">
            <rect class="hilite" x="0" y="0" width="160" height="24"></rect>
            <text x="0" y="44">start=1, end=4, i=4 ⇒ start = 1</text>
          </g>
          <!-- arrows for outgoing/incoming at i=4 -->
          <line class="arrow" x1="110" y1="62" x2="78" y2="28"></line>
          <text x="35" y="26" class="idx">outgoing = i - m</text>
          <line class="arrow" x1="270" y1="62" x2="304" y2="28"></line>
          <text x="310" y="26" class="idx">incoming = i</text>
        </svg>
      </figure>
      <div class="diagram" aria-label="Backward slide window indexing diagram">
        Backward slide (leftward), m = 4 (less common but useful conceptually)
        
        From window [start, end] = [k, k+3], slide left to [k-1, k+2]
          - outgoing index (rightmost) = k + (m - 1)
          - incoming index (new left)  = k - 1
          - next start                 = k - 1
        
        Note: a leftward roll requires dividing by base (using the modular inverse of base) and
        adding the new left character at weight base^(m-1). If modular inverse doesn’t exist,
        prefer rightward scans or recompute the hash for the new window.
      </div>
      <figure class="viz" aria-label="Backward slide window indexing SVG diagram">
        <svg viewBox="0 0 560 120" role="img">
          <defs>
            <marker id="arrowhead2" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
              <path d="M0,0 L6,3 L0,6 Z" fill="#0f172a"></path>
            </marker>
          </defs>
          <text class="idx" x="10" y="20">Leftward slide (concept), m=4</text>
          <!-- window [k, k+3] and [k-1, k+2] -->
          <g transform="translate(40,40)">
            <rect class="hilite" x="80" y="0" width="160" height="24"></rect>
            <text x="80" y="44">[k, k+3]</text>
            <rect class="hilite" x="40" y="70" width="160" height="24"></rect>
            <text x="40" y="114">[k-1, k+2]</text>
            <line class="arrow" x1="240" y1="12" x2="280" y2="12" marker-end="url(#arrowhead2)"></line>
            <text class="idx" x="290" y="16">outgoing = k + (m-1)</text>
            <line class="arrow" x1="40" y1="82" x2="0" y2="82" marker-end="url(#arrowhead2)"></line>
            <text class="idx" x="-5" y="70">incoming = k - 1</text>
          </g>
        </svg>
      </figure>

      <h2 id="mod">9. Modulo Math Essentials</h2>
      <p>Modulo arithmetic underpins rolling hashes. Core properties with modulus <code>M</code>:</p>
      <ul>
        <li><strong>Addition:</strong> <code>(a + b) % M = ((a % M) + (b % M)) % M</code></li>
        <li><strong>Subtraction:</strong> <code>(a - b) % M = ((a % M) - (b % M) + M) % M</code> (normalize to avoid negatives)</li>
        <li><strong>Multiplication:</strong> <code>(a * b) % M = ((a % M) * (b % M)) % M</code></li>
        <li><strong>Exponent:</strong> use fast power: <code>pow(base, exp, M)</code> in Python runs in O(log exp)</li>
        <li><strong>Division:</strong> multiply by modular inverse when it exists (e.g., <code>a / b ≡ a * b^{-1} (mod M)</code>)</li>
        <li><strong>Associativity/Commutativity:</strong> <code>+ , *</code> remain associative and commutative under mod.</li>
        <li><strong>Distributivity:</strong> <code>((a + b) * c) % M = ((a % M) * (c % M) + (b % M) * (c % M)) % M</code></li>
        <li><strong>Congruence:</strong> <code>a ≡ b (mod M)</code> iff <code>M</code> divides <code>a - b</code>; you can replace <code>a</code> by <code>b</code> in any sum/product.</li>
        <li><strong>Residues:</strong> every integer has a unique representative in <code>[0, M-1]</code> after reduction.</li>
      </ul>
      <div class="tip">When <code>M</code> is prime and <code>b % M != 0</code>, the inverse is <code>b^{M-2} % M</code> (Fermat’s little theorem). Otherwise use the extended Euclidean algorithm if <code>gcd(b, M)=1</code>.</div>
      <pre><code class="language-python"># Essentials in Python
def add_mod(a,b,M): return (a + b) % M
def sub_mod(a,b,M): return (a - b) % M  # Python already returns non-negative
def mul_mod(a,b,M): return (a * b) % M
def pow_mod(a,e,M): return pow(a, e, M)  # O(log e)
def inv_mod_prime(a,M):
    if a % M == 0: raise ZeroDivisionError('no inverse')
    return pow(a, M-2, M)

# Extended Euclid inverse (works when gcd(a,M)=1)
def egcd(a,b):
    if b==0: return (a,1,0)
    g,x1,y1 = egcd(b, a%b)
    return (g, y1, x1 - (a//b)*y1)
def inv_mod(a,M):
    g,x,_ = egcd(a,M)
    if g != 1: raise ZeroDivisionError('no inverse')
    return x % M
      </code></pre>
      <ul>
        <li><strong>Normalization:</strong> in C/C++/Java normalize with <code>(x % M + M) % M</code> after subtraction. Python’s <code>%</code> already yields non-negative.</li>
        <li><strong>Overflow:</strong> prefer 64-bit; for <code>a*b % M</code> in C++ use <code>__int128</code> or Montgomery; Python bigints are safe.</li>
        <li><strong>Choosing M:</strong> large primes near <code>1e9+7</code>/<code>1e9+9</code>; for double hashing, use two independent primes.</li>
        <li><strong>Precompute powers:</strong> <code>pow(base, i, M)</code> or <code>pow(base, m-1, M)</code> to remove outgoing char in O(1).</li>
      </ul>

      <h2 id="modtricks">10. Mod Tricks for Interviews</h2>
      <ul>
        <li><strong>Sliding windows:</strong> remove outgoing term with a precomputed power, then multiply and add incoming, all mod <code>M</code>.</li>
        <li><strong>Avoid negatives:</strong> always normalize after subtraction before the next multiply.</li>
        <li><strong>Fast exponent:</strong> use <code>pow(base, exp, M)</code> instead of repeated multiplication.</li>
        <li><strong>Inverse on primes:</strong> <code>inv = pow(a, M-2, M)</code>; otherwise use extended Euclid.</li>
        <li><strong>Double hashing:</strong> compute two hashes with different <code>(base, M)</code> to reduce collision probability.</li>
        <li><strong>Randomized bases:</strong> choose base at runtime to defend against adversarial inputs.</li>
        <li><strong>nCr mod p (p prime):</strong> precompute <code>fact</code> and <code>invfact</code> arrays for O(1) queries.</li>
        <li><strong>Prefix sums mod p:</strong> take every addition mod <code>p</code>; differences use normalized subtraction.</li>
      </ul>
      <pre><code class="language-python"># nCr modulo prime p with precomputation
def build_nCr(N, p=1_000_000_007):
    fact = [1]*(N+1)
    for i in range(1, N+1):
        fact[i] = (fact[i-1]*i) % p
    invfact = [1]*(N+1)
    invfact[N] = pow(fact[N], p-2, p)
    for i in range(N, 0, -1):
        invfact[i-1] = (invfact[i]*i) % p
    def nCr(n, r):
        if r < 0 or r > n: return 0
        return (((fact[n]*invfact[r])%p)*invfact[n-r])%p
    return nCr
      </code></pre>

      <h2 id="usage">11. Where Rabin–Karp Shines</h2>
      <p>
        Rabin–Karp is particularly effective when you need to scan a large text once for many fixed-length patterns, or when fast elimination via hashes saves expensive string compares. Common use cases include:
      </p>
      <ul>
        <li><strong>Plagiarism detection:</strong> compare shingles (fixed-length substrings) across large corpora using hashed windows.</li>
        <li><strong>Bioinformatics:</strong> search for k-mers (DNA substrings of length k) across genomes efficiently.</li>
        <li><strong>Intrusion/log scanning:</strong> detect known signatures across logs/memory dumps using precomputed hashes.</li>
        <li><strong>Duplicate detection:</strong> find repeated substrings (e.g., "Repeated DNA Sequences") via rolling hashes and sets.</li>
        <li><strong>Multi-pattern lookup:</strong> when the number of patterns is large but all have the same length.</li>
      </ul>
      <pre><code class="language-python"># Tiny demo: find indices of a short pattern using a base-256 rolling hash
def rk_find_all(text, pat, base=256, M=1_000_000_007):
    n, m = len(text), len(pat)
    if m == 0 or m > n: return []
    pow_m_1 = pow(base, m-1, M)
    th = ph = 0
    for i in range(m):
        th = (th * base + ord(text[i])) % M
        ph = (ph * base + ord(pat[i])) % M
    out = [0] if th == ph and text[:m] == pat else []
    for i in range(m, n):
        th = (th - ord(text[i-m]) * pow_m_1) % M
        th = (th * base + ord(text[i])) % M
        if th == ph:
            j = i - m + 1
            if text[j:j+m] == pat:
                out.append(j)
    return out
      </code></pre>

      <h3>Example: Repeated DNA Sequences (k-mers)</h3>
      <p>
        Classic bioinformatics task: find all repeated DNA substrings of fixed length <code>L</code>.
        Use a base-4 rolling hash with mapping <code>A→0</code>, <code>C→1</code>, <code>G→2</code>, <code>T→3</code> for O(1) window updates.
      </p>
      <pre><code class="language-python">def repeated_kmers_dna(s: str, L: int = 10):
    if len(s) <= L: return []
    to_int = {'A':0,'C':1,'G':2,'T':3}
    a = 4
    aL = pow(a, L)
    nums = [to_int[c] for c in s]
    h = 0
    seen, out = set(), set()
    for i in range(len(s) - L + 1):
        if i:
            h = h * a - nums[i-1] * aL + nums[i+L-1]
        else:
            for j in range(L):
                h = h * a + nums[j]
        if h in seen:
            out.add(s[i:i+L])
        seen.add(h)
    return sorted(out)

# Example
# repeated_kmers_dna('AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT', 10)
      </code></pre>

      <h2 id="kmp">12. KMP: Quick Primer</h2>
      <p>
        Knuth–Morris–Pratt (KMP) solves single-pattern search in O(n + m) by precomputing a failure function (also called LPS/"longest prefix which is also suffix"). This table tells how far to shift the pattern on mismatch without re-checking characters, eliminating backtracking in the text.
      </p>
      <pre><code class="language-python"># Build LPS array used by KMP
def build_lps(p):
    lps = [0]*len(p)
    k = 0
    for i in range(1, len(p)):
        while k and p[i] != p[k]:
            k = lps[k-1]
        if p[i] == p[k]:
            k += 1
        lps[i] = k
    return lps
      </code></pre>
      <p class="tip">
        Usage contrast: prefer <strong>KMP</strong> for one pattern against one large text. Prefer <strong>Rabin–Karp</strong> for many equal-length patterns, shingling, or when hashing enables constant-time window updates or quick elimination before exact checks.
      </p>

      <h2 id="compare">13. RK vs KMP: Comparison</h2>
      <table>
        <thead>
          <tr>
            <th>Aspect</th>
            <th>Rabin–Karp (RK)</th>
            <th>KMP</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Goal</td>
            <td>Hash-based filtering, great for multi-pattern, fixed-length windows</td>
            <td>Deterministic single-pattern search without backtracking</td>
          </tr>
          <tr>
            <td>Time complexity</td>
            <td>Average O(n + m); worst O(nm) if many collisions</td>
            <td>O(n + m) worst-case</td>
          </tr>
          <tr>
            <td>Preprocessing</td>
            <td>Precompute powers; pattern hash; optional double hash</td>
            <td>Compute LPS table for pattern</td>
          </tr>
          <tr>
            <td>Collisions</td>
            <td>Possible; must verify on hash match; double hashing reduces risk</td>
            <td>None; exact character comparisons guided by LPS</td>
          </tr>
          <tr>
            <td>Multiple patterns</td>
            <td>Efficient for many patterns of same length using a hash set</td>
            <td>Requires building multiple LPS tables or Aho–Corasick for many patterns</td>
          </tr>
          <tr>
            <td>Typical uses</td>
            <td>Plagiarism detection, k-mer search, log signature scan, duplicate substrings</td>
            <td>Editor "Find", exact single-pattern search, streaming match</td>
          </tr>
          <tr>
            <td>Memory</td>
            <td>O(1) plus optional hash sets for seen windows</td>
            <td>O(m) for LPS</td>
          </tr>
        </tbody>
      </table>

      <h2 id="practice">14. Practice Exercises</h2>
      <ol>
        <li>Implement Rabin–Karp to return <em>all</em> occurrences of a pattern in a text.</li>
        <li>Implement double hashing and compare collision behavior on random data.</li>
        <li>Given many patterns of the same length, use a hash set to find any occurrence.</li>
        <li>Implement fast modular exponentiation <code>pow_mod(a, e, M)</code> and verify correctness by comparing with Python’s <code>pow(a, e, M)</code> on 1000 random cases.</li>
        <li>Implement modular inverse for general <code>M</code> via extended Euclid and for prime <code>M</code> via Fermat. Verify that <code>(a * inv(a)) % M == 1</code> for random <code>a</code> with <code>gcd(a, M)=1</code>.</li>
      </ol>

      <pre><code class="language-python"># Quick correctness harness (small-scale)
import random, math

def pow_mod_ref(a,e,M):
    # your implementation under test
    res = 1; a %= M
    while e:
        if e & 1: res = (res * a) % M
        a = (a * a) % M
        e >>= 1
    return res

def inv_mod_euclid(a,M):
    def egcd(x,y):
        if y==0: return (x,1,0)
        g, p, q = egcd(y, x%y)
        return (g, q, p - (x//y)*q)
    g,x,_ = egcd(a,M)
    if g != 1: return None
    return x % M

def inv_mod_fermat(a,M):
    return pow(a, M-2, M)

def test():
    for _ in range(1000):
        a = random.randrange(1, 10**9+7)
        e = random.randrange(0, 10**6)
        M = 1_000_000_007
        assert pow_mod_ref(a,e,M) == pow(a,e,M)
        # inverse tests
        inv1 = inv_mod_euclid(a,M)
        inv2 = inv_mod_fermat(a,M)
        assert inv1 is not None and (a*inv1) % M == 1
        assert (a*inv2) % M == 1
    print('OK')

# test()
      </code></pre>

      <section id="trapdoors-appendix">
        <h2>Appendix: Rolling Hash Trapdoors (I–V)</h2>
        <p>This appendix consolidates the five “Rolling Hash Trapdoors” mini-articles into a single place, preserving all examples and explanations while aligning them with the Rabin–Karp fundamentals above.</p>

        <h3>I. Polynomial Formulations</h3>
        <p>Canonical left-to-right accumulation corresponds to <code>h = \sum arr[i] * base^i (mod M)</code> and the iterative form below:</p>
        <pre><code class="language-python">def poly_hash(arr, base, M):
    h = 0
    for x in arr:
        h = ((h * base) % M + x) % M
    return h

# Example
print(poly_hash([1,2,3], 10, 1000))  # 123
        </code></pre>
        <ul>
          <li>Define and test <code>poly_hash</code> first — it serves as the ground-truth reference.</li>
          <li>Passing <code>base</code> and <code>M</code> explicitly avoids hidden globals and makes tests reliable.</li>
        </ul>

        <h3>II. Modulus and Normalization</h3>
        <p>We keep values in <code>[0, M)</code> to avoid overflow and maintain good distribution. After subtraction, normalize explicitly:</p>
        <pre><code class="language-python">def sub_mod(h, x, M):
    # Safe: ensure non-negative before the final % M
    return (h - (x % M) + M) % M
        </code></pre>
        <ul>
          <li>Use large primes for <code>M</code> (e.g., <code>1e9+7</code>, <code>1e9+9</code>).</li>
          <li>This pattern mirrors portable code in languages where <code>%</code> can return negatives.</li>
        </ul>

        <h3>III. Sliding Window Update</h3>
        <p>Rightward slide by one character for window length <code>m</code>:</p>
        <pre><code class="language-python">def roll_right(h, s_out, s_in, base, M, pow_m_1):
    # Remove outgoing contribution, multiply, then add incoming
    h = (h - (s_out * pow_m_1) % M + M) % M
    h = (h * base) % M
    h = (h + s_in) % M
    return h

def check_slide(window, nxt, base=256, M=1_000_000_007):
    m = len(window)
    pow_m_1 = pow(base, m-1, M)
    h = poly_hash(window, base, M)
    h2 = roll_right(h, window[0], nxt, base, M, pow_m_1)
    ref = poly_hash(window[1:] + [nxt], base, M)
    assert h2 == ref, (h2, ref)
        </code></pre>
        <ul>
          <li>Order matters: subtract → multiply → add.</li>
          <li>Precompute <code>pow(base, m-1, M)</code> for the outgoing term.</li>
        </ul>

        <h3>IV. Edge Cases and Negatives</h3>
        <p>Be mindful of Unicode/bytes mapping and intermediate negatives.</p>
        <pre><code class="language-python">def to_ints(text):
    # Use bytes for general data; ord(c) for simple demos
    return list(text.encode('utf-8'))

def safe_sub(h, term, M):
    return (h - (term % M) + M) % M
        </code></pre>
        <ul>
          <li>Count windows correctly: a text of length <code>n</code> has <code>n - m + 1</code> windows of length <code>m</code>.</li>
          <li>Always verify substring equality after a hash match to eliminate collisions.</li>
        </ul>

        <h3>V. Double Hashing and Test Order</h3>
        <pre><code class="language-python">def H(arr, base, M):
    h = 0
    for x in arr:
        h = ((h * base) % M + x) % M
    return h

def H2(arr, base1, M1, base2, M2):
    return (H(arr, base1, M1), H(arr, base2, M2))
        </code></pre>
        <ol>
          <li><strong>Poly hash first:</strong> establish the reference.</li>
          <li><strong>Mod/normalization:</strong> subtraction must be correct.</li>
          <li><strong>Rolling update:</strong> validate O(1) transitions against the reference.</li>
          <li><strong>Edge cases:</strong> Unicode/bytes and negatives.</li>
          <li><strong>Double hashing:</strong> combine two independent pairs to reduce collision risk.</li>
        </ol>
      </section>

      <div class="note muted">This article now includes usage patterns, a KMP primer, and an RK vs KMP comparison table, in addition to rolling hash fundamentals, collision handling, multi-pattern strategies, and the consolidated “Trapdoors” appendix.</div>
    </article>
  </main>

  <script>
    // Minimal Python highlighter (same scheme as the app)
    function escapeHtml(s){
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }
    function highlightPython(src){
      if (!src) return '';
      const holders=[]; const keep = html => (holders.push(html), `@@H${holders.length-1}@@`);
      src = src.replace(/('{3}[\s\S]*?'{3}|"{3}[\s\S]*?"{3})/g, m => keep(`<span class="tok-str">${escapeHtml(m)}</span>`));
      src = src.replace(/'(?:\\.|[^'\\])*'|"(?:\\.|[^"\\])*"/g, m => keep(`<span class="tok-str">${escapeHtml(m)}</span>`));
      src = src.replace(/#.*/g, m => keep(`<span class="tok-com">${escapeHtml(m)}</span>`));
      let html = escapeHtml(src);
      const KW = ['def','return','if','elif','else','for','while','in','not','and','or','class','import','from','as','try','except','finally','with','lambda','True','False','None','pass','break','continue','yield','global','nonlocal','assert','raise','del','is'];
      html = html.replace(new RegExp(`\\b(${KW.join('|')})\\b`,'g'), '<span class="tok-kw">$1</span>');
      const BI = ['len','range','print','dict','list','set','tuple','int','str','float','bool','sum','min','max','sorted','enumerate','zip','map','filter'];
      html = html.replace(new RegExp(`\\b(${BI.join('|')})\\b`,'g'), '<span class="tok-builtin">$1</span>');
      html = html.replace(/\b0x[0-9a-fA-F_]+\b|\b\d+(?:\.\d+)?\b/g, '<span class="tok-num">$&</span>');
      return html.replace(/@@H(\d+)@@/g, (m,i)=>holders[Number(i)]);
    }
    function applySyntax(){
      document.querySelectorAll('pre code.language-python').forEach(el => {
        el.innerHTML = highlightPython(el.textContent || '');
      });
    }
    window.addEventListener('DOMContentLoaded', applySyntax);
  </script>
</body>
</html>
