<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modern C++ Low-Latency - Presentation Guide</title>
  <style>
    :root {
      --bg1: #f0f9ff;
      --bg2: #e0f2fe;
      --ink: #0f172a;
      --muted: #64748b;
      --accent: #0284c7;
      --accent-2: #0369a1;
      --card: #ffffff;
      --card-border: #bae6fd;
      --code-bg: #1e293b;
      --code-ink: #f1f5f9;
      --shadow: rgba(2, 132, 199, 0.1);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      background:
        radial-gradient(circle at 10% 10%, rgba(2, 132, 199, 0.05), transparent 40%),
        radial-gradient(circle at 90% 20%, rgba(3, 105, 161, 0.05), transparent 45%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      min-height: 100vh;
    }
    .deck {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .hud {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid var(--card-border);
    }
    .hud.footer {
      border-top: 1px solid var(--card-border);
      border-bottom: none;
      gap: 16px;
      flex-wrap: wrap;
    }
    .brand {
      font-weight: 800;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      font-size: 14px;
      color: var(--accent);
    }
    .slide-title {
      font-weight: 700;
      font-size: 15px;
      color: var(--ink);
      margin-left: 12px;
    }
    .hud-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .hud-btn {
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }
    .hud-btn.secondary {
      background: transparent;
      color: var(--accent);
    }
    .slides {
      flex: 1;
      display: grid;
      place-items: center;
      padding: 24px 18px 8px;
    }
    .slide {
      width: min(980px, 94vw);
      max-height: calc(100vh - 180px);
      padding: 32px;
      border-radius: 16px;
      background: var(--card);
      border: 1px solid var(--card-border);
      box-shadow: 0 20px 40px var(--shadow);
      display: none;
      overflow: auto;
      position: relative;
      animation: fadeIn 0.3s ease;
    }
    .slide.active { display: block; }
    .slide h1 { font-size: 32px; margin: 0 0 16px; color: var(--accent-2); }
    .slide h2 { font-size: 24px; margin: 0 0 16px; color: var(--accent-2); border-bottom: 2px solid var(--bg2); padding-bottom: 8px; }
    .slide h3 { font-size: 18px; margin: 20px 0 10px; color: var(--accent); }
    .slide p, .slide li { line-height: 1.6; margin-bottom: 8px; }
    .slide ul { padding-left: 20px; }
    
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 16px;
    }
    .panel {
      background: var(--bg1);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 16px;
    }
    .note {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
      padding: 12px;
      border-radius: 6px;
      margin-top: 16px;
      font-size: 0.95em;
    }
    pre {
      background: var(--code-bg);
      color: var(--code-ink);
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: ui-monospace, monospace;
      font-size: 14px;
      line-height: 1.5;
      margin: 12px 0;
    }
    code {
      font-family: ui-monospace, monospace;
    }
    .pill {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--bg2);
      color: var(--accent-2);
      font-weight: 700;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    
    /* Quiz Styles */
    .quiz-panel {
      background: #fff;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .quiz-question { font-weight: 600; margin-bottom: 8px; }
    .cloze {
      background: #eee;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    .cloze.reveal {
      background: var(--bg2);
      color: var(--accent-2);
    }
    
    .progress {
      flex: 1;
      height: 8px;
      background: var(--bg2);
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 0.3s;
    }
    .hint { font-size: 12px; color: var(--muted); }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div class="deck">
    <header class="hud">
      <div style="display:flex; align-items:center; gap:10px;">
        <span class="brand">Modern C++ Low-Latency</span>
        <span class="slide-title" id="slide-title">Intro</span>
      </div>
      <div class="hud-right">
        <span id="slide-indicator">1 / 1</span>
        <button class="hud-btn secondary" id="prev-btn">Prev</button>
        <button class="hud-btn" id="next-btn">Next</button>
        <button class="hud-btn" id="quiz-btn">Full Quiz</button>
      </div>
    </header>

    <main class="slides" id="slides">
      
      <section class="slide active" data-title="Intro">
        <span class="pill">Presentation</span>
        <h2>Modern C++ Low-Latency Toolkit</h2>
        <p>Strategies for predictable performance in C++17 through C++23.</p>
        <ul><li>Allocator control</li><li>Zero-cost abstractions</li><li>Atomics & Concurrency</li><li>Data Layout</li></ul>
        <div class='note'>Press Space to navigate.</div>
      </section>

      <section class="slide" data-title="Priorities">
        <span class="pill">Presentation</span>
        <h2>1. Low-Latency Priorities</h2>
        <p>Low-latency C++ is about <strong>predictability</strong>.</p>
        <ul><li>Avoid allocations in hot paths</li><li>Minimize branch mispredictions</li><li>Reduce cache misses</li><li>Explicit error handling</li></ul>
      </section>

      <section class="slide" data-title="Memory">
        <span class="pill">Presentation</span>
        <h2>2. Memory and Allocation Control</h2>
        <p>Memory allocation is a top source of latency spikes.</p>
        <div class='grid-2'>
        <div class='panel'><h3>std::pmr</h3><p>Polymorphic Memory Resources allow swapping allocators without changing types.</p></div>
        <div class='panel'><h3>std::byte</h3><p>Type-safe raw memory, prevents accidental arithmetic.</p></div>
        </div>
        <pre><code>std::byte arena[4096];
std::pmr::monotonic_buffer_resource pool{arena, sizeof(arena)};
std::pmr::vector&lt;int&gt; v{&amp;pool};</code></pre>
      </section>

      <section class="slide" data-title="Quiz: Memory">
        <span class="pill">Quiz</span>
        <h2>Concept Check: Memory</h2>
        <div class="quiz-panel">
            <div class="quiz-question">Q1. Consider the snippet:
```cpp
std::byte arena[1024];
std::pmr::monotonic_buffer_resource pool{arena, sizeof(arena)};
std::pmr::vector<int> v{&pool};
```
Where does v allocate its storage from?</div>
            <pre><code>std::byte arena[1024];
std::pmr::monotonic_buffer_resource pool{arena, sizeof(arena)};
std::pmr::vector<int> v{&pool};</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">The arena buffer</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
        <div class="quiz-panel">
            <div class="quiz-question">Q3. Consider the snippet:
```cpp
struct MyRes : std::pmr::memory_resource {
  void* do_allocate(size_t, size_t) override;
  void do_deallocate(void*, size_t, size_t) override;
  bool do_is_equal(const std::pmr::memory_resource&) const noexcept override;
};
```
What is the key benefit of a custom memory_resource?</div>
            <pre><code>struct MyRes : std::pmr::memory_resource {
  void* do_allocate(size_t, size_t) override;
  void do_deallocate(void*, size_t, size_t) override;
  bool do_is_equal(const std::pmr::memory_resource&) const noexcept override;
};</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Custom allocation policy without changing container types</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
      </section>

      <section class="slide" data-title="Zero Cost">
        <span class="pill">Presentation</span>
        <h2>3. Zero-Cost Abstractions</h2>
        <p>Move work to compile time.</p>
        <ul><li><strong>Concepts:</strong> Constrain templates</li><li><strong>consteval:</strong> Force compile-time eval</li></ul>
        <pre><code>template &lt;ByteLike T&gt;
constexpr int parse_hex(T c) { ... }</code></pre>
      </section>

      <section class="slide" data-title="Quiz: Zero Cost">
        <span class="pill">Quiz</span>
        <h2>Concept Check: Abstractions</h2>
        <div class="quiz-panel">
            <div class="quiz-question">Q6. Consider the snippet:
```cpp
consteval auto make_table(){
  std::array<int,4> a{1,2,3,4};
  return a;
}
constexpr auto table = make_table();
```
When is make_table executed?</div>
            <pre><code>consteval auto make_table(){
  std::array<int,4> a{1,2,3,4};
  return a;
}
constexpr auto table = make_table();</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">At compile time only</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
        <div class="quiz-panel">
            <div class="quiz-question">Q11. Consider the snippet:
```cpp
template <typename T>
int f(T v){
  if constexpr (std::is_integral_v<T>) return v + 1;
  else return 0;
}
```
What does if constexpr enable?</div>
            <pre><code>template <typename T>
int f(T v){
  if constexpr (std::is_integral_v<T>) return v + 1;
  else return 0;
}</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Compile-time branching</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
      </section>

      <section class="slide" data-title="Concurrency">
        <span class="pill">Presentation</span>
        <h2>5. Concurrency & Atomics</h2>
        <p><strong>std::atomic_ref:</strong> Atomic ops on existing non-atomic data.</p>
        <p><strong>std::jthread:</strong> RAII thread handle that requests stop on destruction.</p>
        <pre><code>std::atomic_ref&lt;int&gt; a(counter);
a.fetch_add(1, std::memory_order_relaxed);</code></pre>
      </section>

      <section class="slide" data-title="Quiz: Concurrency">
        <span class="pill">Quiz</span>
        <h2>Concept Check: Concurrency</h2>
        <div class="quiz-panel">
            <div class="quiz-question">Q18. Consider the snippet:
```cpp
int counter = 0;
std::atomic_ref<int> a(counter);
a.fetch_add(1, std::memory_order_relaxed);
```
What does atomic_ref provide here?</div>
            <pre><code>int counter = 0;
std::atomic_ref<int> a(counter);
a.fetch_add(1, std::memory_order_relaxed);</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Atomic ops on existing memory</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
        <div class="quiz-panel">
            <div class="quiz-question">Q21. Consider the snippet:
```cpp
std::jthread t([](std::stop_token st){
  while (!st.stop_requested()) {
    // work
  }
});
```
What happens when t is destroyed?</div>
            <pre><code>std::jthread t([](std::stop_token st){
  while (!st.stop_requested()) {
    // work
  }
});</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">It requests stop and joins</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
      </section>

      <section class="slide" data-title="Layout">
        <span class="pill">Presentation</span>
        <h2>6. Data Layout</h2>
        <p><strong>alignas:</strong> Prevent false sharing.</p>
        <p><strong>[[no_unique_address]]:</strong> Optimize empty members.</p>
        <p><strong>std::span:</strong> Zero-copy views.</p>
        <pre><code>struct alignas(64) Slot { std::atomic&lt;int&gt; v; };</code></pre>
      </section>

      <section class="slide" data-title="Quiz: Layout">
        <span class="pill">Quiz</span>
        <h2>Concept Check: Layout</h2>
        <div class="quiz-panel">
            <div class="quiz-question">Q23. Consider the snippet:
```cpp
struct alignas(64) Slot { std::atomic<int> v; };
```
What is a likely reason for alignas(64) here?</div>
            <pre><code>struct alignas(64) Slot { std::atomic<int> v; };</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Reduce false sharing</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
        <div class="quiz-panel">
            <div class="quiz-question">Q25. Consider the snippet:
```cpp
struct E{};
struct S {
  [[no_unique_address]] E e;
  int x;
};
```
What is the effect of [[no_unique_address]] here?</div>
            <pre><code>struct E{};
struct S {
  [[no_unique_address]] E e;
  int x;
};</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">e may occupy no storage</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
      </section>

      <section class="slide" data-title="I/O">
        <span class="pill">Presentation</span>
        <h2>7. I/O on Hot Paths</h2>
        <p>Use <code>std::from_chars</code> and <code>std::to_chars</code>.</p>
        <ul><li>No allocations</li><li>No locale overhead</li><li>Direct buffer access</li></ul>
      </section>

      <section class="slide" data-title="Quiz: I/O">
        <span class="pill">Quiz</span>
        <h2>Concept Check: I/O</h2>
        <div class="quiz-panel">
            <div class="quiz-question">Q32. Consider the snippet:
```cpp
char buf[] = "123";
int value = 0;
auto [ptr, ec] = std::from_chars(buf, buf + 3, value);
```
What is a key benefit of from_chars?</div>
            <pre><code>char buf[] = "123";
int value = 0;
auto [ptr, ec] = std::from_chars(buf, buf + 3, value);</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Allocation-free parsing</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
        <div class="quiz-panel">
            <div class="quiz-question">Q33. Consider the snippet:
```cpp
char out[32];
auto [ptr, ec] = std::to_chars(out, out + 32, 12345);
```
What does to_chars do?</div>
            <pre><code>char out[32];
auto [ptr, ec] = std::to_chars(out, out + 32, 12345);</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Formats numbers into a user buffer without allocating</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
      </section>

      <section class="slide" data-title="Errors">
        <span class="pill">Presentation</span>
        <h2>8. Error Handling</h2>
        <p>Avoid exceptions in hot paths.</p>
        <p><strong>std::expected</strong> (C++23) gives explicit error return types.</p>
        <pre><code>std::expected&lt;int, Error&gt; r = parse();</code></pre>
      </section>

      <section class="slide" data-title="Quiz: Errors">
        <span class="pill">Quiz</span>
        <h2>Concept Check: Errors</h2>
        <div class="quiz-panel">
            <div class="quiz-question">Q36. Consider the snippet:
```cpp
std::expected<int, Error> r = parse();
if (!r) return r.error();
```
What does std::expected enable?</div>
            <pre><code>std::expected<int, Error> r = parse();
if (!r) return r.error();</code></pre>
            <div class="panel">
                <strong>Answer:</strong> <span class="cloze" onclick="this.classList.add('reveal')">Click to reveal</span>
                <span class="cloze-content" style="display:none">Explicit error handling without exceptions</span>
            </div>
             <script>
                document.currentScript.parentElement.querySelector('.cloze').addEventListener('click', function() {
                    this.nextElementSibling.style.display = 'inline';
                    this.style.display = 'none';
                });
            </script>
        </div>
    
      </section>

      <section class="slide" data-title="Wrap Up">
        <span class="pill">Presentation</span>
        <h2>Summary</h2>
        <ul><li>Predictability over raw throughput.</li><li>Type system is your friend (concepts, expected).</li><li>Control your memory layout and allocation.</li></ul>
        <div class='note'>Full quiz available via the button below.</div>
      </section>

    </main>

    <footer class="hud footer">
      <div class="progress"><div class="progress-bar" id="progress-bar"></div></div>
      <div class="hint">Space: next | Shift+Space: prev | Home/End: jump</div>
    </footer>
  </div>
  <script src="assets/modern-cpp-low-latency.js"></script>
</body>
</html>
