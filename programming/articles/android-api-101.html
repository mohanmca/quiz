
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Android API 101 for Kotlin Driver Apps</title>
<style>
:root{--primary:#0b74de;--bg:#f6f8fb;--card:#ffffff;--text:#0f172a;--muted:#6b7280}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
header{background:#fff;border-bottom:1px solid #e2e8f0;position:sticky;top:0;z-index:20}
.container{max-width:1100px;margin:0 auto;padding:18px}
.title{font-size:28px;font-weight:800;margin:4px 0}
.subtitle{color:var(--muted);margin-bottom:12px}
.toolbar{display:flex;gap:8px;flex-wrap:wrap}
button{border:none;border-radius:8px;padding:10px 16px;font-weight:600;cursor:pointer}
button.secondary{background:var(--primary);color:#fff}
button.ghost{background:transparent;color:var(--text);border:1px solid #cbd5f5}
main.container article{background:#fff;margin-top:16px;border-radius:16px;border:1px solid #e2e8f0;padding:24px}
h2{margin-top:36px;font-size:24px}
h3{margin-top:20px;font-size:20px}
p{line-height:1.7;margin-top:12px}
.api-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;margin-top:20px}
.api-card{border:1px solid #e4e7ec;border-radius:12px;padding:14px;background:var(--card)}
.api-card h4{margin:0 0 8px;font-size:16px}
.api-card p{margin:8px 0 0}
pre{background:#0f172a;color:#e2e8f0;padding:12px;border-radius:12px;overflow:auto;font-size:14px}
code{font-family:'JetBrains Mono',Consolas,monospace}
.note{background:#fef3c7;border:1px solid #fde68a;border-radius:12px;padding:12px;margin-top:16px}
.toc ul{columns:2;padding-left:20px}
</style>
</head><body>
<header><div class="container">
  <div class="title">Android API 101 for Kotlin Developers</div>
  <div class="subtitle">151 battle-tested APIs and classes to ship truck-driver workflows faster</div>
  <div class="toolbar">
    <button class="secondary" onclick="window.location.href='../index.html?id=android-api-101'">Start Quiz</button>
    <button class="ghost" onclick="window.location.href='../index.html'">All Quizzes</button>
  </div>
</div></header>
<main class="container"><article>
<div class="toc"><strong>Contents</strong>
  <ul>
    <li><a href="#section-1">1. Core Lifecycle</a></li>
    <li><a href="#section-2">2. Kotlin Concurrency</a></li>
    <li><a href="#section-3">3. Compose Basics</a></li>
    <li><a href="#section-4">4. Compose Layout & Animation</a></li>
    <li><a href="#section-5">5. View System & Material</a></li>
    <li><a href="#section-6">6. Navigation & DI</a></li>
    <li><a href="#section-7">7. Data & Storage</a></li>
    <li><a href="#section-8">8. Networking & Serialization</a></li>
    <li><a href="#section-9">9. Permissions & Security</a></li>
    <li><a href="#section-10">10. Location & Sensors</a></li>
    <li><a href="#section-11">11. Background Work & System</a></li>

  </ul>
</div>
<p>This handbook is written for Kotlin engineers who need to assemble production Android applications quickly—think driver workflows, telematics dashboards, and compliance consoles. Instead of prose-heavy essays, you get tactic-heavy callouts organized by API. Every entry answers two questions: what does this API unlock, and how does it help you move faster?</p>
<h2 id="section-1">1. Core Lifecycle</h2>
<p>Lay down guardrails around Activities, Fragments, and lifecycle owners so developers can wire Kotlin features quickly without losing state.</p>

<pre><code class="language-kotlin">@AndroidEntryPoint
class ManifestActivity : ComponentActivity() {
    private val vm: ManifestViewModel by viewModels()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(object : DefaultLifecycleObserver {
            override fun onStart(owner: LifecycleOwner) {
                vm.refreshAssignments()
            }
        })
    }
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>Application</h4><p>Central entry point that initializes global dependencies before any Activity runs.</p><p><strong>Speed Focus:</strong> pair Application with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>Context</h4><p>Handle to application and system services required to inflate layouts, access resources, and obtain managers quickly.</p><p><strong>Speed Focus:</strong> pair Context with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>Intent</h4><p>Message object used to request an activity, service, or broadcast and ferry typed extras.</p><p><strong>Speed Focus:</strong> pair Intent with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>Bundle</h4><p>Key-value container that carries primitive or Parcelable state across process recreation boundaries.</p><p><strong>Speed Focus:</strong> pair Bundle with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>Activity</h4><p>UI entry point responsible for window setup, permission dialogs, and lifecycle-aware resource management.</p><p><strong>Speed Focus:</strong> pair Activity with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>Fragment</h4><p>Modular UI/controller component seated inside activities to keep screens composable and testable.</p><p><strong>Speed Focus:</strong> pair Fragment with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>ComponentActivity</h4><p>Base class that fuses Jetpack lifecycle + ViewModel owners for modern Kotlin-first screens.</p><p><strong>Speed Focus:</strong> pair ComponentActivity with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>FragmentManager</h4><p>Coordinator that attaches, detaches, and restores fragments plus the navigation back stack.</p><p><strong>Speed Focus:</strong> pair FragmentManager with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>ViewModel</h4><p>Lifecycle-aware holder for screen state and business logic that survives configuration changes.</p><p><strong>Speed Focus:</strong> pair ViewModel with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>SavedStateHandle</h4><p>Key-value store automatically scoped to a ViewModel for persisting user input quickly.</p><p><strong>Speed Focus:</strong> pair SavedStateHandle with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>LifecycleOwner</h4><p>Interface implemented by Activities, Fragments, and Compose hosts so observers can watch state changes.</p><p><strong>Speed Focus:</strong> pair LifecycleOwner with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>DefaultLifecycleObserver</h4><p>Convenient observer with typed callbacks (onCreate, onStart, etc.) for hooking into hosts without reflection.</p><p><strong>Speed Focus:</strong> pair DefaultLifecycleObserver with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>ProcessLifecycleOwner</h4><p>Singleton that reports when the entire app enters foreground or background.</p><p><strong>Speed Focus:</strong> pair ProcessLifecycleOwner with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>LiveData</h4><p>Observable data holder that only notifies active lifecycle owners on the main thread.</p><p><strong>Speed Focus:</strong> pair LiveData with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div><div class="api-card"><h4>MutableLiveData</h4><p>Mutable variant of LiveData for pushing UI updates from repositories, ViewModels, or services.</p><p><strong>Speed Focus:</strong> pair MutableLiveData with ViewModel + SavedStateHandle to reload screens instantly after rotation.</p></div></div>
<h2 id="section-2">2. Kotlin Concurrency</h2>
<p>Coroutines, scopes, and Flow primitives keep network calls, sensor sampling, and uploads responsive.</p>

<pre><code class="language-kotlin">class ManifestViewModel @Inject constructor(
    private val repo: LoadRepository
) : ViewModel() {
    val loads = MutableStateFlow(ManifestUi())
    init {
        viewModelScope.launch {
            repo.observeStops().collect { loads.value = it }
        }
    }
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>CoroutineScope</h4><p>Structured concurrency boundary that launches jobs tied to lifecycle-aware cancellation.</p><p><strong>Speed Focus:</strong> use CoroutineScope to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>SupervisorJob</h4><p>Parent job that keeps sibling coroutines alive even if one fails.</p><p><strong>Speed Focus:</strong> use SupervisorJob to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>Dispatchers.Main</h4><p>Main-thread dispatcher for UI work, composition, and LiveData bridging.</p><p><strong>Speed Focus:</strong> use Dispatchers.Main to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>Dispatchers.IO</h4><p>Thread pool optimized for disk and network operations without starving the main loop.</p><p><strong>Speed Focus:</strong> use Dispatchers.IO to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>viewModelScope</h4><p>Auto-created CoroutineScope tied to each ViewModel for fire-and-forget background work.</p><p><strong>Speed Focus:</strong> use viewModelScope to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>lifecycleScope</h4><p>CoroutineScope bound to LifecycleOwners, ideal for collecting Flow from UI layers.</p><p><strong>Speed Focus:</strong> use lifecycleScope to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>MutableStateFlow</h4><p>Hot Flow that stores the latest value and emits updates to collectors instantly.</p><p><strong>Speed Focus:</strong> use MutableStateFlow to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>StateFlow</h4><p>Read-only Flow counterpart for exposing immutable state to Compose or LiveData bridges.</p><p><strong>Speed Focus:</strong> use StateFlow to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>SharedFlow</h4><p>Broadcast Flow for fan-out events such as analytics pings or navigation commands.</p><p><strong>Speed Focus:</strong> use SharedFlow to cancel stale requests and keep UIs snapping between tabs.</p></div><div class="api-card"><h4>Channel</h4><p>Coroutine-friendly queue for one-off tasks or streaming sensor samples with back-pressure.</p><p><strong>Speed Focus:</strong> use Channel to cancel stale requests and keep UIs snapping between tabs.</p></div></div>
<h2 id="section-3">3. Compose Basics</h2>
<p>Compose primitives get the UI on screen faster with less XML and instant previews.</p>

<pre><code class="language-kotlin">@Composable
fun ManifestScreen(state: ManifestUi, onRefresh: () -&gt; Unit) {
    Scaffold(topBar = { TopAppBar(title = { Text("Today") }) }) { padding -&gt;
        Column(Modifier.padding(padding)) {
            Text(text = state.summary)
            Button(onClick = onRefresh) { Text("Sync") }
        }
    }
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>Composable</h4><p>Annotation describing a function that contributes UI to the Compose tree.</p><p><strong>Speed Focus:</strong> compose previews powered by Composable shave minutes off each UI iteration.</p></div><div class="api-card"><h4>Modifier</h4><p>Fluent object for sizing, padding, gesture detection, and semantics adjustments in Compose.</p><p><strong>Speed Focus:</strong> compose previews powered by Modifier shave minutes off each UI iteration.</p></div><div class="api-card"><h4>remember</h4><p>Utility that stores objects in composition so expensive work runs once per recomposition group.</p><p><strong>Speed Focus:</strong> compose previews powered by remember shave minutes off each UI iteration.</p></div><div class="api-card"><h4>rememberSaveable</h4><p>State saver that persists values across activity recreation using Parcelables or Saver objects.</p><p><strong>Speed Focus:</strong> compose previews powered by rememberSaveable shave minutes off each UI iteration.</p></div><div class="api-card"><h4>MutableState</h4><p>Backed property delegate whose changes trigger recomposition of dependent Composables.</p><p><strong>Speed Focus:</strong> compose previews powered by MutableState shave minutes off each UI iteration.</p></div><div class="api-card"><h4>State</h4><p>Read-only wrapper around MutableState for exposing immutable views of UI state.</p><p><strong>Speed Focus:</strong> compose previews powered by State shave minutes off each UI iteration.</p></div><div class="api-card"><h4>LaunchedEffect</h4><p>Coroutine launcher that reacts to key changes and runs suspend functions without leaking.</p><p><strong>Speed Focus:</strong> compose previews powered by LaunchedEffect shave minutes off each UI iteration.</p></div><div class="api-card"><h4>rememberCoroutineScope</h4><p>Shortcut for grabbing a scope tied to the current composition.</p><p><strong>Speed Focus:</strong> compose previews powered by rememberCoroutineScope shave minutes off each UI iteration.</p></div><div class="api-card"><h4>SideEffect</h4><p>Hook to perform thread-safe, synchronous work (like imperatively updating a map camera) post-draw.</p><p><strong>Speed Focus:</strong> compose previews powered by SideEffect shave minutes off each UI iteration.</p></div><div class="api-card"><h4>Scaffold</h4><p>High-level layout that wires top bars, FABs, snackbars, and body content consistently.</p><p><strong>Speed Focus:</strong> compose previews powered by Scaffold shave minutes off each UI iteration.</p></div><div class="api-card"><h4>TopAppBar</h4><p>Material component implementing a toolbar with icons, titles, and scroll behaviors.</p><p><strong>Speed Focus:</strong> compose previews powered by TopAppBar shave minutes off each UI iteration.</p></div><div class="api-card"><h4>NavigationRail</h4><p>Vertical navigation component optimized for tablets and desktop-style layouts.</p><p><strong>Speed Focus:</strong> compose previews powered by NavigationRail shave minutes off each UI iteration.</p></div><div class="api-card"><h4>SnackbarHost</h4><p>Composable responsible for queuing and rendering snackbars triggered by ScaffoldState.</p><p><strong>Speed Focus:</strong> compose previews powered by SnackbarHost shave minutes off each UI iteration.</p></div><div class="api-card"><h4>Text</h4><p>Composable text primitive honoring typography, color, and accessibility scaling.</p><p><strong>Speed Focus:</strong> compose previews powered by Text shave minutes off each UI iteration.</p></div><div class="api-card"><h4>Icon</h4><p>Composable wrapper for vector and bitmap assets with automatic tinting.</p><p><strong>Speed Focus:</strong> compose previews powered by Icon shave minutes off each UI iteration.</p></div><div class="api-card"><h4>Button</h4><p>Clickable Material surface for primary actions with ripple, elevation, and disabled states.</p><p><strong>Speed Focus:</strong> compose previews powered by Button shave minutes off each UI iteration.</p></div><div class="api-card"><h4>OutlinedTextField</h4><p>Input component with validation states, leading icons, and IME action hooks.</p><p><strong>Speed Focus:</strong> compose previews powered by OutlinedTextField shave minutes off each UI iteration.</p></div><div class="api-card"><h4>Card</h4><p>Container with elevation and rounded corners for grouping related driver data.</p><p><strong>Speed Focus:</strong> compose previews powered by Card shave minutes off each UI iteration.</p></div></div>
<h2 id="section-4">4. Compose Layout & Animation</h2>
<p>Layout and animation APIs turn telemetry into readable dashboards without frame drops.</p>

<pre><code class="language-kotlin">@Composable
fun SensorTimeline(events: List&lt;BrakeEvent&gt;) {
    LazyRow {
        items(events) { event -&gt;
            AnimatedVisibility(visible = event.active) {
                Card { Text(event.label) }
            }
        }
    }
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>LazyColumn</h4><p>Highly optimized vertical list that composes items on demand.</p><p><strong>Speed Focus:</strong> connect sensor state to LazyColumn so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>LazyRow</h4><p>Horizontal list ideal for chip carousels or fleet card scrollers.</p><p><strong>Speed Focus:</strong> connect sensor state to LazyRow so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>LazyVerticalGrid</h4><p>Two-dimensional grid for dashboards, filters, or feature shelves.</p><p><strong>Speed Focus:</strong> connect sensor state to LazyVerticalGrid so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>FlowRow</h4><p>Responsive row that wraps items to the next line when width is constrained.</p><p><strong>Speed Focus:</strong> connect sensor state to FlowRow so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>ConstraintLayout (Compose)</h4><p>Constraint-based Compose layout for intricate alignments without nested Rows/Columns.</p><p><strong>Speed Focus:</strong> connect sensor state to ConstraintLayout (Compose) so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>MotionLayout (Compose)</h4><p>Animation-aware constraint system for gestures, transitions, and sensor-driven layouts.</p><p><strong>Speed Focus:</strong> connect sensor state to MotionLayout (Compose) so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>AnimatedVisibility</h4><p>Utility that fades/expands content when boolean state toggles.</p><p><strong>Speed Focus:</strong> connect sensor state to AnimatedVisibility so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>Crossfade</h4><p>Transition API swapping between two composables with cross-fade animation.</p><p><strong>Speed Focus:</strong> connect sensor state to Crossfade so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>AnimatedContent</h4><p>Animates size and content changes when target state mutates.</p><p><strong>Speed Focus:</strong> connect sensor state to AnimatedContent so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>rememberInfiniteTransition</h4><p>Creates time-based animations (pulses, shimmer) without manual coroutine plumbing.</p><p><strong>Speed Focus:</strong> connect sensor state to rememberInfiniteTransition so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>Canvas (Compose)</h4><p>Low-level drawing surface for charts, maps, and sensor visualizations.</p><p><strong>Speed Focus:</strong> connect sensor state to Canvas (Compose) so motion feels purposeful, not gimmicky.</p></div><div class="api-card"><h4>Dialog (Compose)</h4><p>Composable modal window supporting custom content and lifecycle-aware dismissal.</p><p><strong>Speed Focus:</strong> connect sensor state to Dialog (Compose) so motion feels purposeful, not gimmicky.</p></div></div>
<h2 id="section-5">5. View System & Material</h2>
<p>Legacy view components still matter for hybrid stacks, so keep a curated toolkit ready.</p>

<pre><code class="language-kotlin">class StopAdapter : ListAdapter&lt;Stop, StopVH&gt;(diff) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        StopVH(ItemStopBinding.inflate(layoutInflater(parent), parent, false))
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>RecyclerView</h4><p>Flexible list container that reuses child views for efficient scrolling.</p><p><strong>Speed Focus:</strong> wrap RecyclerView behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>ListAdapter</h4><p>RecyclerView adapter with DiffUtil support baked in for painless updates.</p><p><strong>Speed Focus:</strong> wrap ListAdapter behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>DiffUtil</h4><p>Utility that computes list diffs on background threads for smooth UI refreshes.</p><p><strong>Speed Focus:</strong> wrap DiffUtil behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>ViewBinding</h4><p>Generated binding classes that replace findViewById with type-safe accessors.</p><p><strong>Speed Focus:</strong> wrap ViewBinding behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>DataBindingUtil</h4><p>Helper for inflating databound layouts and binding ViewModels declaratively.</p><p><strong>Speed Focus:</strong> wrap DataBindingUtil behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>ConstraintLayout</h4><p>Powerful XML layout enabling flat hierarchies with constraint chains.</p><p><strong>Speed Focus:</strong> wrap ConstraintLayout behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>MotionLayout</h4><p>ConstraintLayout extension for rich transitions driven by keyframes or progress values.</p><p><strong>Speed Focus:</strong> wrap MotionLayout behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>CoordinatorLayout</h4><p>Layout that coordinates scroll behaviors between child views like AppBar + RecyclerView.</p><p><strong>Speed Focus:</strong> wrap CoordinatorLayout behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>AppBarLayout</h4><p>Toolbar container that collapses/expands based on nested scrolling child input.</p><p><strong>Speed Focus:</strong> wrap AppBarLayout behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>NestedScrollView</h4><p>ScrollView variant that participates in nested scrolling with CoordinatorLayout.</p><p><strong>Speed Focus:</strong> wrap NestedScrollView behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>ViewPager2</h4><p>Widget for swiping between fragments or views with RecyclerView under the hood.</p><p><strong>Speed Focus:</strong> wrap ViewPager2 behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>TabLayout</h4><p>Material tabs component that syncs with ViewPager2 or Compose nav destinations.</p><p><strong>Speed Focus:</strong> wrap TabLayout behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>SwipeRefreshLayout</h4><p>Layout wrapper providing pull-to-refresh affordances with Compose interop.</p><p><strong>Speed Focus:</strong> wrap SwipeRefreshLayout behind adapters so classic layouts coexist with Compose.</p></div><div class="api-card"><h4>MaterialToolbar</h4><p>Material Components implementation of Toolbar with menu, navigation, and color theming.</p><p><strong>Speed Focus:</strong> wrap MaterialToolbar behind adapters so classic layouts coexist with Compose.</p></div></div>
<h2 id="section-6">6. Navigation & DI</h2>
<p>Navigation and Hilt remove boilerplate when wiring modules, permissions, and deep links.</p>

<pre><code class="language-kotlin">NavHost(navController, startDestination = "manifest") {
    composable("manifest") { ManifestScreen(...) }
    composable("stop/{id}") { backStackEntry -&gt;
        StopScreen(id = backStackEntry.arguments?.getString("id")!!)
    }
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>NavController</h4><p>Central navigation orchestrator handling back stack, deep links, and arguments.</p><p><strong>Speed Focus:</strong> drive feature toggles through NavController so routes stay predictable.</p></div><div class="api-card"><h4>NavHostFragment</h4><p>Fragment that hosts composables or views defined inside a nav graph.</p><p><strong>Speed Focus:</strong> drive feature toggles through NavHostFragment so routes stay predictable.</p></div><div class="api-card"><h4>NavGraphBuilder</h4><p>DSL entry point for declaring composable or fragment destinations in Kotlin.</p><p><strong>Speed Focus:</strong> drive feature toggles through NavGraphBuilder so routes stay predictable.</p></div><div class="api-card"><h4>NavOptions</h4><p>Configuration object for animations, popUpTo rules, and launchSingleTop semantics.</p><p><strong>Speed Focus:</strong> drive feature toggles through NavOptions so routes stay predictable.</p></div><div class="api-card"><h4>NavDeepLinkBuilder</h4><p>Builder that constructs PendingIntents which open destinations with arguments prefilled.</p><p><strong>Speed Focus:</strong> drive feature toggles through NavDeepLinkBuilder so routes stay predictable.</p></div><div class="api-card"><h4>HiltAndroidApp</h4><p>Annotation that triggers Hilt code generation for Application subclasses.</p><p><strong>Speed Focus:</strong> drive feature toggles through HiltAndroidApp so routes stay predictable.</p></div><div class="api-card"><h4>AndroidEntryPoint</h4><p>Annotation marking Activities, Fragments, or Services as Hilt injection targets.</p><p><strong>Speed Focus:</strong> drive feature toggles through AndroidEntryPoint so routes stay predictable.</p></div><div class="api-card"><h4>HiltViewModel</h4><p>Annotation hooking a ViewModel into the Hilt graph with @Inject constructors.</p><p><strong>Speed Focus:</strong> drive feature toggles through HiltViewModel so routes stay predictable.</p></div><div class="api-card"><h4>EntryPointAccessors</h4><p>Utility for fetching Hilt bindings from classes that cannot use @AndroidEntryPoint.</p><p><strong>Speed Focus:</strong> drive feature toggles through EntryPointAccessors so routes stay predictable.</p></div><div class="api-card"><h4>SingletonComponent</h4><p>Default Hilt component scope for app-wide singletons.</p><p><strong>Speed Focus:</strong> drive feature toggles through SingletonComponent so routes stay predictable.</p></div></div>
<h2 id="section-7">7. Data & Storage</h2>
<p>Modern driver apps juggle offline data, config, and paged manifests—Room + DataStore speed things up.</p>

<pre><code class="language-kotlin">@Dao
interface StopDao {
    @Query("SELECT * FROM stops WHERE routeId = :routeId")
    fun observeStops(routeId: String): PagingSource&lt;Int, StopEntity&gt;
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>RoomDatabase</h4><p>Abstract base class tying DAOs together and configuring migrations for Room.</p><p><strong>Speed Focus:</strong> combine RoomDatabase with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>Room</h4><p>ORM abstraction that generates SQL and type-safe DAO implementations.</p><p><strong>Speed Focus:</strong> combine Room with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>Entity</h4><p>Annotation describing a Room table schema tied to Kotlin data classes.</p><p><strong>Speed Focus:</strong> combine Entity with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>Dao</h4><p>Interface whose annotated methods perform type-safe SQL queries and updates.</p><p><strong>Speed Focus:</strong> combine Dao with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>Transaction</h4><p>Annotation ensuring multi-query methods run atomically.</p><p><strong>Speed Focus:</strong> combine Transaction with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>PagingSource</h4><p>Data source that loads pages of results for infinite scroll experiences.</p><p><strong>Speed Focus:</strong> combine PagingSource with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>PagingData</h4><p>Immutable stream of paged items consumed by Paging adapters or Compose.</p><p><strong>Speed Focus:</strong> combine PagingData with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>Pager</h4><p>Helper that coordinates PagingSource creation, config, and Flow emission.</p><p><strong>Speed Focus:</strong> combine Pager with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>RemoteMediator</h4><p>Component syncing network + database to keep Paging layers fresh.</p><p><strong>Speed Focus:</strong> combine RemoteMediator with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>DataStore</h4><p>Coroutines-first key-value store replacing SharedPreferences with predictable I/O.</p><p><strong>Speed Focus:</strong> combine DataStore with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>PreferencesDataStoreFactory</h4><p>Factory for building preference DataStore instances from Context.</p><p><strong>Speed Focus:</strong> combine PreferencesDataStoreFactory with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>ProtoDataStore</h4><p>Typed DataStore powered by Protocol Buffers for structured config/state.</p><p><strong>Speed Focus:</strong> combine ProtoDataStore with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>SharedPreferences</h4><p>Legacy key-value store still handy for small synchronous flags.</p><p><strong>Speed Focus:</strong> combine SharedPreferences with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>EncryptedSharedPreferences</h4><p>Drop-in SharedPreferences replacement that encrypts keys + values transparently.</p><p><strong>Speed Focus:</strong> combine EncryptedSharedPreferences with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>SQLiteOpenHelper</h4><p>Helper for managing custom SQLite schemas without Room.</p><p><strong>Speed Focus:</strong> combine SQLiteOpenHelper with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>ContentResolver</h4><p>Facade for querying ContentProviders and observing cursor changes.</p><p><strong>Speed Focus:</strong> combine ContentResolver with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>FileProvider</h4><p>ContentProvider that shares app-private files via secure content URIs.</p><p><strong>Speed Focus:</strong> combine FileProvider with Flow to stream data straight into UI without middle layers.</p></div><div class="api-card"><h4>MediaStore</h4><p>Indexed media provider for photos, audio, and downloads.</p><p><strong>Speed Focus:</strong> combine MediaStore with Flow to stream data straight into UI without middle layers.</p></div></div>
<h2 id="section-8">8. Networking & Serialization</h2>
<p>HTTP clients and JSON tools turn REST feeds into Kotlin models quickly.</p>

<pre><code class="language-kotlin">interface FleetService {
    @GET("routes/{id}")
    suspend fun fetchRoute(@Path("id") id: String): RouteDto
}
</code></pre>

<div class="api-grid"><div class="api-card"><h4>Retrofit</h4><p>Declarative HTTP client that turns annotated interfaces into suspend functions.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on Retrofit for plumbing.</p></div><div class="api-card"><h4>OkHttpClient</h4><p>Low-level HTTP stack powering Retrofit with interceptors and connection pooling.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on OkHttpClient for plumbing.</p></div><div class="api-card"><h4>HttpLoggingInterceptor</h4><p>OkHttp interceptor that logs request/response data for debugging.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on HttpLoggingInterceptor for plumbing.</p></div><div class="api-card"><h4>WebSocket</h4><p>Duplex socket built into OkHttp for live location or messaging streams.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on WebSocket for plumbing.</p></div><div class="api-card"><h4>Moshi</h4><p>JSON serialization library with Kotlin code gen and adapters.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on Moshi for plumbing.</p></div><div class="api-card"><h4>Gson</h4><p>Google's JSON library still useful for dynamic payloads or legacy APIs.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on Gson for plumbing.</p></div><div class="api-card"><h4>KtorClient</h4><p>Multiplatform coroutine-based HTTP client for shared Kotlin modules.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on KtorClient for plumbing.</p></div><div class="api-card"><h4>JsonAdapter</h4><p>Moshi adapter class customizing how specific models serialize.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on JsonAdapter for plumbing.</p></div><div class="api-card"><h4>SerializedName</h4><p>Gson annotation mapping JSON fields to Kotlin property names.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on SerializedName for plumbing.</p></div><div class="api-card"><h4>MultipartBody</h4><p>OkHttp payload builder for file uploads such as proof-of-delivery images.</p><p><strong>Speed Focus:</strong> keep Retrofit interfaces skinny by leaning on MultipartBody for plumbing.</p></div></div>
<h2 id="section-9">9. Permissions & Security</h2>
<p>Permission and crypto APIs keep sensitive freight data safe while minimizing user friction.</p>

<pre><code class="language-kotlin">val launcher = rememberLauncherForActivityResult(
    ActivityResultContracts.RequestPermission()
) { granted -&gt; if (granted) syncGps() }
</code></pre>

<div class="api-grid"><div class="api-card"><h4>ActivityResultLauncher</h4><p>Lifecycle-aware launcher for requesting permissions or intents without onActivityResult.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around ActivityResultLauncher.</p></div><div class="api-card"><h4>ActivityResultContracts</h4><p>Set of ready-made contracts (RequestPermission, TakePicture, etc.) for ActivityResultLauncher.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around ActivityResultContracts.</p></div><div class="api-card"><h4>PermissionChecker</h4><p>Utility that reports permission grant state even from services.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around PermissionChecker.</p></div><div class="api-card"><h4>BiometricPrompt</h4><p>High-level API for fingerprint, face, or device credential auth flows.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around BiometricPrompt.</p></div><div class="api-card"><h4>CryptoObject</h4><p>Wrapper for Cipher/Signature when using BiometricPrompt crypto modes.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around CryptoObject.</p></div><div class="api-card"><h4>KeyStore</h4><p>Secure storage for cryptographic keys bound to hardware when available.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around KeyStore.</p></div><div class="api-card"><h4>KeyGenParameterSpec</h4><p>Builder specifying key properties (purposes, digests, user auth).</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around KeyGenParameterSpec.</p></div><div class="api-card"><h4>Cipher</h4><p>JCA class performing symmetric encryption/decryption for secure payloads.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around Cipher.</p></div><div class="api-card"><h4>Signature</h4><p>JCA class that signs data with asymmetric keys for attestation.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around Signature.</p></div><div class="api-card"><h4>SafetyNetClient</h4><p>API for device attestation and Play Protect integrity verdicts.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around SafetyNetClient.</p></div><div class="api-card"><h4>IdentityCredential</h4><p>API for secure documents (mobile IDs) stored on modern devices.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around IdentityCredential.</p></div><div class="api-card"><h4>DevicePolicyManager</h4><p>Administrator API controlling lock task, kiosk, and security policies.</p><p><strong>Speed Focus:</strong> script repeatable permission flows by centralizing them around DevicePolicyManager.</p></div></div>
<h2 id="section-10">10. Location & Sensors</h2>
<p>Location, Bluetooth, and telephony APIs feed dispatch decisions in real time.</p>

<pre><code class="language-kotlin">val client = LocationServices.getFusedLocationProviderClient(context)
client.requestLocationUpdates(locationRequest, callback, Looper.getMainLooper())
</code></pre>

<div class="api-grid"><div class="api-card"><h4>SensorManager</h4><p>System service that enumerates sensors and registers listeners efficiently.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through SensorManager everywhere.</p></div><div class="api-card"><h4>Sensor</h4><p>Hardware or virtual sensor descriptor describing type, range, and accuracy.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through Sensor everywhere.</p></div><div class="api-card"><h4>SensorEvent</h4><p>Data payload delivered to listeners with timestamped readings.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through SensorEvent everywhere.</p></div><div class="api-card"><h4>SensorEventListener</h4><p>Interface receiving sensor events and handling accuracy changes.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through SensorEventListener everywhere.</p></div><div class="api-card"><h4>LocationManager</h4><p>System service for GNSS, network, and passive providers.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through LocationManager everywhere.</p></div><div class="api-card"><h4>LocationRequest</h4><p>Configuration object describing update interval, displacement, and priority.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through LocationRequest everywhere.</p></div><div class="api-card"><h4>FusedLocationProviderClient</h4><p>Google Play services client combining GPS, Wi-Fi, and cell signals.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through FusedLocationProviderClient everywhere.</p></div><div class="api-card"><h4>LocationServices</h4><p>Entry point for fused location, geofencing, and settings clients.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through LocationServices everywhere.</p></div><div class="api-card"><h4>GeofencingClient</h4><p>API for registering enter/exit/dwell triggers around important areas.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through GeofencingClient everywhere.</p></div><div class="api-card"><h4>Geofence</h4><p>Geo boundary definition with radius, transitions, and loitering delay.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through Geofence everywhere.</p></div><div class="api-card"><h4>SettingsClient</h4><p>Checker that ensures location settings match app requirements before requesting updates.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through SettingsClient everywhere.</p></div><div class="api-card"><h4>ActivityRecognitionClient</h4><p>Client delivering IN_VEHICLE/ON_BICYCLE/STILL transitions via Play services.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through ActivityRecognitionClient everywhere.</p></div><div class="api-card"><h4>ActivityTransitionRequest</h4><p>Batch request describing activity enter/exit pairs monitored by ActivityRecognitionClient.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through ActivityTransitionRequest everywhere.</p></div><div class="api-card"><h4>BluetoothAdapter</h4><p>Entry point for classic Bluetooth discovery, pairing, and enablement state.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through BluetoothAdapter everywhere.</p></div><div class="api-card"><h4>BluetoothDevice</h4><p>Concrete device handle for initiating connections or bonding.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through BluetoothDevice everywhere.</p></div><div class="api-card"><h4>BluetoothLeScanner</h4><p>BLE scanning API delivering ScanResult callbacks on worker threads.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through BluetoothLeScanner everywhere.</p></div><div class="api-card"><h4>TelephonyManager</h4><p>Service exposing cellular network identity, signal strength, and SIM state.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through TelephonyManager everywhere.</p></div><div class="api-card"><h4>PowerManager</h4><p>Service reporting interactive/doze state plus APIs to request temporary wake locks.</p><p><strong>Speed Focus:</strong> calibrate sampling intervals once and push them through PowerManager everywhere.</p></div></div>
<h2 id="section-11">11. Background Work & System</h2>
<p>Schedulers and notifications keep telemetry alive even when the activity is gone.</p>

<pre><code class="language-kotlin">val work = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()
    .setConstraints(Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build())
    .build()
WorkManager.getInstance(context).enqueue(work)
</code></pre>

<div class="api-grid"><div class="api-card"><h4>WorkManager</h4><p>Jetpack scheduler guaranteeing deferrable work with constraint support.</p><p><strong>Speed Focus:</strong> gate your uploads with WorkManager so jobs never block UI sessions.</p></div><div class="api-card"><h4>OneTimeWorkRequest</h4><p>WorkRequest subtype for single execution tasks.</p><p><strong>Speed Focus:</strong> gate your uploads with OneTimeWorkRequest so jobs never block UI sessions.</p></div><div class="api-card"><h4>PeriodicWorkRequest</h4><p>WorkRequest subtype for repeated execution with flex windows.</p><p><strong>Speed Focus:</strong> gate your uploads with PeriodicWorkRequest so jobs never block UI sessions.</p></div><div class="api-card"><h4>Constraints</h4><p>Object describing required network, battery, idle, or storage conditions for WorkRequests.</p><p><strong>Speed Focus:</strong> gate your uploads with Constraints so jobs never block UI sessions.</p></div><div class="api-card"><h4>Worker</h4><p>Base class whose doWork() runs off the main thread.</p><p><strong>Speed Focus:</strong> gate your uploads with Worker so jobs never block UI sessions.</p></div><div class="api-card"><h4>CoroutineWorker</h4><p>Worker variant exposing suspend doWork for structured concurrency.</p><p><strong>Speed Focus:</strong> gate your uploads with CoroutineWorker so jobs never block UI sessions.</p></div><div class="api-card"><h4>ListenableWorker</h4><p>Extensible Worker allowing callback-based async APIs.</p><p><strong>Speed Focus:</strong> gate your uploads with ListenableWorker so jobs never block UI sessions.</p></div><div class="api-card"><h4>JobScheduler</h4><p>System-level API for OS-managed background jobs on API 21+.</p><p><strong>Speed Focus:</strong> gate your uploads with JobScheduler so jobs never block UI sessions.</p></div><div class="api-card"><h4>JobInfo</h4><p>Configuration blob describing requirements for JobScheduler jobs.</p><p><strong>Speed Focus:</strong> gate your uploads with JobInfo so jobs never block UI sessions.</p></div><div class="api-card"><h4>AlarmManager</h4><p>Scheduler for exact or inexact alarms that wake apps at specific times.</p><p><strong>Speed Focus:</strong> gate your uploads with AlarmManager so jobs never block UI sessions.</p></div><div class="api-card"><h4>PendingIntent</h4><p>Token granting other apps permission to execute pre-defined work as if from you.</p><p><strong>Speed Focus:</strong> gate your uploads with PendingIntent so jobs never block UI sessions.</p></div><div class="api-card"><h4>NotificationChannel</h4><p>Required grouping for notifications on Android 8+ with importance + sound control.</p><p><strong>Speed Focus:</strong> gate your uploads with NotificationChannel so jobs never block UI sessions.</p></div><div class="api-card"><h4>NotificationCompat</h4><p>Support library builder to craft backwards-compatible notifications quickly.</p><p><strong>Speed Focus:</strong> gate your uploads with NotificationCompat so jobs never block UI sessions.</p></div><div class="api-card"><h4>BatteryManager</h4><p>API exposing charge level, health, and energy counters for diagnostics.</p><p><strong>Speed Focus:</strong> gate your uploads with BatteryManager so jobs never block UI sessions.</p></div></div>
<h2 id="build-playbook">12. Build Faster Checklist</h2>
<p>Pin this checklist next to your Kanban board. Every bullet links back to at least one API above:</p>
<ul>
  <li>Bootstrap features with Hilt modules, Nav graphs, and WorkManager chains before you pixel-polish.</li>
  <li>Model every network or sensor feed as a Flow so Compose and RecyclerView stay in sync.</li>
  <li>Record lifecycle, location, and job status into DataStore or Room so QA can replay bugs.</li>
  <li>Automate permission flows via ActivityResultLauncher and choreograph results inside Scaffold snackbars.</li>
  <li>Validate background behavior weekly using WorkManager inspection, dumpsys, and the quiz attached to this article.</li>
</ul>
</article></main>
</body></html>
